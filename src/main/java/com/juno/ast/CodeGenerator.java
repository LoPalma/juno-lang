package com.juno.ast;

// Import types package explicitly
// Don't import com.juno.types.* to avoid conflicts - import specific classes instead

import com.juno.types.PrimitiveType;
import com.juno.types.ArrayType;
import com.juno.types.UnionType;
import org.objectweb.asm.*;
import org.objectweb.asm.commons.GeneratorAdapter;
import org.objectweb.asm.commons.Method;

import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Map;

import static org.objectweb.asm.Opcodes.*;

/**
 * JVM Code generator that translates Juno AST to JVM bytecode using the visitor pattern.
 * Each AST node type has a corresponding visit method that generates appropriate bytecode.
 */
public class CodeGenerator implements ASTVisitor<Void> {

	private ClassWriter classWriter;
	private GeneratorAdapter methodGenerator;  // ASM utility for method generation
	private String currentClassName;
	private Map<String, Integer> localVariables;  // Track local variable slots
	private Map<String, com.juno.types.Type> globalVariables;  // Track global variables (static fields)
	private Map<String, Expression> globalInitializers;  // Track global variable initializers
	private com.juno.types.Type currentFunctionReturnType;  // Track current function's return type
	private int nextLocalSlot;
	private int labelCounter = 0;  // Counter for unique labels

	// Break/continue label stack for loops
	private final java.util.Stack<Label> breakLabels = new java.util.Stack<>();
	private final java.util.Stack<Label> continueLabels = new java.util.Stack<>();

	// Jasmin assembly generation
	// private PrintWriter jasminWriter;
	private StringBuilder jasminOutput;
	private boolean hasJunoMainMethod = false;
	private com.juno.types.Type junoMainReturnType = null;

	public void generate(Program program, String outputPath) throws IOException {
		generate(program, outputPath, true); // Default: generate Jasmin
	}

	public void generate(Program program, String outputPath, boolean generateJasmin) throws IOException {
		System.out.println("Starting JVM bytecode generation...");

		// Extract class name from output path
		String className = extractClassName(outputPath);
		this.currentClassName = className;
		this.localVariables = new HashMap<>();
		this.globalVariables = new HashMap<>();
		this.globalInitializers = new HashMap<>();
		this.nextLocalSlot = 1; // 0 is reserved for 'this' (even in static methods)

		// Initialize Jasmin assembly output
		this.jasminOutput = new StringBuilder();
		generateJasminHeader(className);

		// Create ASM ClassWriter
		classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);

		// Generate class header
		classWriter.visit(V1_8, ACC_PUBLIC, className, null, "java/lang/Object", null);

		// Generate default constructor
		generateDefaultConstructor();

		// Visit the program AST
		program.accept(this);

		// Generate static initializer for global variables
		generateStaticInitializer();

		// Generate JVM-compatible main method if we have a Juno main
		generateJvmMainMethod();

		// Finalize class
		classWriter.visitEnd();

		// Write bytecode to file
		byte[] bytecode = classWriter.toByteArray();
		String outputFile = outputPath.endsWith(".class") ? outputPath : outputPath + ".class";

		try (FileOutputStream fos = new FileOutputStream(outputFile)) {
			fos.write(bytecode);
		}

		System.out.println("Generated bytecode: " + outputFile);
		System.out.println("Run with: java " + className);

		// Conditionally write Jasmin assembly file
		if (generateJasmin) {
			String jasminFile = outputPath.replaceAll("\\.class$|\\.cl$", "") + ".j";
			try (PrintWriter writer = new PrintWriter(new FileWriter(jasminFile))) {
				writer.print(jasminOutput.toString());
			}
			System.out.println("Generated Jasmin assembly: " + jasminFile);
		}
	}

	private String extractClassName(String path) {
		// Extract class name from path like "examples/hello" -> "hello"
		String name = path;
		if (name.contains("/")) {
			name = name.substring(name.lastIndexOf("/") + 1);
		}
		if (name.contains(".")) {
			name = name.substring(0, name.indexOf("."));
		}
		return name;
	}

	private void generateDefaultConstructor() {
		MethodVisitor constructor = classWriter.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
		constructor.visitCode();
		constructor.visitVarInsn(ALOAD, 0);  // Load 'this'
		constructor.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
		constructor.visitInsn(RETURN);
		constructor.visitMaxs(0, 0);
		constructor.visitEnd();
	}

	// ===== PROGRAM AND TOP-LEVEL =====

	@Override
	public Void visitProgram(Program program) {
		for (Statement stmt : program.getStatements()) {
			stmt.accept(this);
		}
		return null;
	}

	@Override
	public Void visitModuleDeclaration(ModuleDeclaration module) {
		// For now, treat module contents as regular declarations
		for (Statement stmt : module.getStatements()) {
			stmt.accept(this);
		}
		return null;
	}

	@Override
	public Void visitImportStatement(ImportStatement importStmt) {
		// Imports are handled at compile time, no runtime bytecode needed
		return null;
	}

	@Override
	public Void visitTypeAlias(TypeAlias alias) {
		// com.juno.types.Type aliases are compile-time only, no runtime bytecode needed
		return null;
	}

	@Override
	public Void visitStructDeclaration(StructDeclaration structDecl) {
		jasminComment("Struct declaration: " + structDecl.getName());
		// TODO: Generate JVM class for struct
		// For now, structs are not fully implemented in code generation
		return null;
	}

	// ===== FUNCTION AND VARIABLE DECLARATIONS =====

	@Override
	public Void visitFunctionDeclaration(FunctionDeclaration funcDecl) {
		String methodName = funcDecl.name();
		String methodDescriptor = buildMethodDescriptor(funcDecl);

		// Track if we have a main method (int, long, or void return)
		if (methodName.equals("main") &&
				(methodDescriptor.equals("()I") || methodDescriptor.equals("()J") || methodDescriptor.equals("()V"))) {
			hasJunoMainMethod = true;
			junoMainReturnType = funcDecl.returnType();
		}

		// Track current function's return type
		currentFunctionReturnType = funcDecl.returnType();

		// Generate Jasmin method header
		jasminComment("Function: " + methodName + methodDescriptor);
		jasminMethod(methodName + methodDescriptor, "public static");
		jasminDirective("    .limit stack 20");  // Conservative estimate
		jasminDirective("    .limit locals 20"); // Conservative estimate

		// Create method (public static for now)
		MethodVisitor methodVisitor = classWriter.visitMethod(
				ACC_PUBLIC | ACC_STATIC,
				methodName,
				methodDescriptor,
				null,
				null
		);

		// Initialize method generation context
		Method method = new Method(methodName, methodDescriptor);
		methodGenerator = new GeneratorAdapter(ACC_PUBLIC | ACC_STATIC, method, methodVisitor);

		// Reset local variables for this method
		localVariables.clear();
		nextLocalSlot = 0; // Static methods don't have 'this'

		// Assign slots to parameters
		for (FunctionDeclaration.Parameter param : funcDecl.parameters()) {
			localVariables.put(param.name(), nextLocalSlot);
			nextLocalSlot += getTypeSize(param.type());
		}

		methodGenerator.visitCode();

		// Generate function body
		if (funcDecl.body() != null) {
			funcDecl.body().accept(this);
		}

		// For void methods, add return if missing
		com.juno.types.Type returnType = funcDecl.returnType();
		if (returnType.getName().equals("void")) {
			methodGenerator.visitInsn(RETURN);
			jasminInstruction("return");
		}
		// Non-void methods should have explicit return statements (verified by type checker)

		methodGenerator.visitMaxs(0, 0);
		methodGenerator.visitEnd();

		// End Jasmin method
		jasminEndMethod();

		return null;
	}

	@Override
	public Void visitVariableDeclaration(VariableDeclaration varDecl) {
		String varName = varDecl.name();
		com.juno.types.Type varType = varDecl.getDeclaredType();

		if (methodGenerator == null) {
			// Global variable - create as static field
			String fieldDescriptor = getJVMTypeDescriptor(varType);

			// Track global variable and its initializer
			globalVariables.put(varName, varType);
			if (varDecl.initializer() != null) {
				globalInitializers.put(varName, varDecl.initializer());
			}

			// Create the static field
			FieldVisitor fieldVisitor = classWriter.visitField(
					ACC_PUBLIC | ACC_STATIC,
					varName,
					fieldDescriptor,
					null,
					null  // Will be initialized in static initializer
			);
			fieldVisitor.visitEnd();

			// Generate Jasmin field
			jasminField(varName, fieldDescriptor, "public static");

		}
		else {
			// Local variable - handle as before
			jasminComment("Local variable: " + varType.getName() + " " + varName);

			// Assign local variable slot
			localVariables.put(varName, nextLocalSlot);
			int varSlot = nextLocalSlot;
			nextLocalSlot += getTypeSize(varType);

			// Generate initialization code
			if (varDecl.initializer() != null) {
				varDecl.initializer().accept(this);  // Generate value on stack

				// Add type conversion if needed between initializer and variable type
				com.juno.types.Type initializerType = varDecl.initializer().getType();
				if (initializerType != null && !initializerType.equals(varType)) {
					jasminComment("Convert " + initializerType.getName() + " to " + varType.getName());
					generateTypeConversion(initializerType, varType);
				}

				storeVariable(varType, varSlot);        // Store in local variable
			}
			else {
				// Initialize with default value
				jasminComment("Initialize " + varName + " with default value");
				generateDefaultValue(varType);
				storeVariable(varType, varSlot);
			}
		}

		return null;
	}

	@Override
	public Void visitBreakStatement(BreakStatement stmt) {
		if (breakLabels.isEmpty()) {
			throw new RuntimeException("break statement not inside loop at line " + stmt.line());
		}

		jasminComment("Break statement");
		Label breakLabel = breakLabels.peek();
		methodGenerator.visitJumpInsn(GOTO, breakLabel);
		jasminInstruction("goto break_target");

		return null;
	}

	@Override
	public Void visitContinueStatement(ContinueStatement stmt) {
		if (continueLabels.isEmpty()) {
			throw new RuntimeException("continue statement not inside loop at line " + stmt.line());
		}

		jasminComment("Continue statement");
		Label continueLabel = continueLabels.peek();
		methodGenerator.visitJumpInsn(GOTO, continueLabel);
		jasminInstruction("goto continue_target");

		return null;
	}

	// ===== ARRAY HELPER METHODS =====

	@Override
	public Void visitBlockStatement(BlockStatement block) {
		for (Statement stmt : block.statements()) {
			stmt.accept(this);
		}
		return null;
	}

	@Override
	public Void visitExpressionStatement(ExpressionStatement exprStmt) {
		exprStmt.expression().accept(this);
		// Pop the result only if the expression returns a value
		Expression expr = exprStmt.expression();
		if (expr.getType() != null && !"void".equals(expr.getType().getName())) {
			methodGenerator.visitInsn(POP);
		}
		return null;
	}

	@Override
	public Void visitReturnStatement(ReturnStatement returnStmt) {
		if (returnStmt.value() != null) {
			jasminComment("Return with value");
			returnStmt.value().accept(this);  // Generate return value

			// CRITICAL: Handle type conversion for long returns
			// Always convert to long when function returns long, since most expressions
			// produce int values on the JVM stack regardless of AST-level type inference
			if (isLongType(currentFunctionReturnType)) {
				// Check if the return expression produces a long value or needs conversion
				if (producesLongValue(returnStmt.value()) ||
						isLongArithmeticExpression(returnStmt.value())) {
					jasminComment("Return value already long - no conversion needed");
				}
				else {
					jasminComment("Converting int to long for ulong return");
					methodGenerator.visitInsn(I2L);
					jasminInstruction("i2l");
				}
			}

			// Use the function's declared return type
			generateReturn(currentFunctionReturnType);
		}
		else {
			jasminComment("Return void");
			methodGenerator.visitInsn(RETURN);
			jasminInstruction("return");
		}
		return null;
	}

	@Override
	public Void visitIfStatement(IfStatement ifStmt) {
		Label elseLabel = methodGenerator.newLabel();
		Label endLabel = methodGenerator.newLabel();
		int elseLabelId = ++labelCounter;
		int endLabelId = ++labelCounter;

		// Generate condition
		ifStmt.condition().accept(this);
		methodGenerator.visitJumpInsn(IFEQ, elseLabel);  // Jump to else if false
		jasminInstruction("ifeq else_" + elseLabelId);

		// Generate then branch
		ifStmt.getThenStatement().accept(this);
		methodGenerator.visitJumpInsn(GOTO, endLabel);
		jasminInstruction("goto end_" + endLabelId);

		// Generate else branch
		methodGenerator.visitLabel(elseLabel);
		jasminLabel("else_" + elseLabelId);
		if (ifStmt.getElseStatement() != null) {
			ifStmt.getElseStatement().accept(this);
		}

		methodGenerator.visitLabel(endLabel);
		jasminLabel("end_" + endLabelId);
		return null;
	}

	@Override
	public Void visitWhileStatement(WhileStatement whileStmt) {
		Label startLabel = methodGenerator.newLabel();
		Label endLabel = methodGenerator.newLabel();
		int startLabelId = ++labelCounter;
		int endLabelId = ++labelCounter;

		jasminComment("While loop start");

		// Push loop labels for break/continue
		breakLabels.push(endLabel);
		continueLabels.push(startLabel);

		// Start of loop
		methodGenerator.visitLabel(startLabel);
		jasminLabel("while_start_" + startLabelId);

		// Generate condition
		whileStmt.condition().accept(this);
		methodGenerator.visitJumpInsn(IFEQ, endLabel);  // Exit if false
		jasminInstruction("ifeq while_end_" + endLabelId);

		// Generate body
		whileStmt.body().accept(this);

		// Jump back to condition
		methodGenerator.visitJumpInsn(GOTO, startLabel);
		jasminInstruction("goto while_start_" + startLabelId);

		// End of loop
		methodGenerator.visitLabel(endLabel);
		jasminLabel("while_end_" + endLabelId);

		// Pop loop labels
		breakLabels.pop();
		continueLabels.pop();

		return null;
	}

	@Override
	public Void visitForInStatement(ForInStatement forStmt) {
		// TODO: Implement for-in loops (requires iterator support)
		throw new UnsupportedOperationException("For-in loops not yet supported in code generation");
	}

	// ===== EXPRESSIONS =====

	@Override
	public Void visitBinaryExpression(BinaryExpression expr) {
		String operator = expr.getOperator();

		// Generate left operand
		expr.getLeft().accept(this);
		boolean leftProducesLong = producesLongValue(expr.getLeft());

		// Generate right operand
		expr.getRight().accept(this);
		boolean rightProducesLong = producesLongValue(expr.getRight());

		// Convert operands to long if needed for mixed arithmetic
		boolean isLongArithmetic = leftProducesLong || rightProducesLong;
		if (isLongArithmetic) {
			if (rightProducesLong && !leftProducesLong) {
				// Right is long, left is int - need to promote left
				// Stack: [int, long_low, long_high] -> [long_low, long_high, long_low, long_high]
				methodGenerator.visitInsn(DUP2_X1);  // Duplicate long below int
				methodGenerator.visitInsn(POP2);     // Remove duplicated long
				methodGenerator.visitInsn(I2L);      // Convert int to long
				methodGenerator.visitInsn(DUP2_X2);  // Move converted long below original long
				methodGenerator.visitInsn(POP2);     // Remove duplicated converted long
				jasminInstruction("dup2_x1");
				jasminInstruction("pop2");
				jasminInstruction("i2l");
				jasminInstruction("dup2_x2");
				jasminInstruction("pop2");
			}
			else if (leftProducesLong && !rightProducesLong) {
				// Left is long, right is int - need to promote right
				// Stack: [long_low, long_high, int] -> [long_low, long_high, long_low, long_high]
				methodGenerator.visitInsn(I2L);      // Convert int to long
				jasminInstruction("i2l");
			}
		}

		switch (operator) {
			case "+":
				if (isLongArithmetic) {
					methodGenerator.visitInsn(LADD);
					jasminInstruction("ladd");
				}
				else {
					methodGenerator.visitInsn(IADD);
					jasminInstruction("iadd");
				}
				break;
			case "-":
				if (isLongArithmetic) {
					methodGenerator.visitInsn(LSUB);
					jasminInstruction("lsub");
				}
				else {
					methodGenerator.visitInsn(ISUB);
					jasminInstruction("isub");
				}
				break;
			case "*":
				if (isLongArithmetic) {
					methodGenerator.visitInsn(LMUL);
					jasminInstruction("lmul");
				}
				else {
					methodGenerator.visitInsn(IMUL);
					jasminInstruction("imul");
				}
				break;
			case "/":
				if (isLongArithmetic) {
					methodGenerator.visitInsn(LDIV);
					jasminInstruction("ldiv");
				}
				else {
					methodGenerator.visitInsn(IDIV);
					jasminInstruction("idiv");
				}
				break;
			case "%":
				if (isLongArithmetic) {
					methodGenerator.visitInsn(LREM);
					jasminInstruction("lrem");
				}
				else {
					methodGenerator.visitInsn(IREM);
					jasminInstruction("irem");
				}
				break;
			case "<":
				generateComparison(IF_ICMPLT);
				break;
			case "<=":
				generateComparison(IF_ICMPLE);
				jasminComment("Comparison: <=");
				break;
			case ">":
				generateComparison(IF_ICMPGT);
				jasminComment("Comparison: >");
				break;
			case ">=":
				generateComparison(IF_ICMPGE);
				jasminComment("Comparison: >=");
				break;
			case "==":
				generateComparison(IF_ICMPEQ);
				break;
			case "!=":
				generateComparison(IF_ICMPNE);
				break;
			case "&&":
				generateLogicalAnd();
				break;
			case "||":
				generateLogicalOr();
				break;
			case "^^":
				generateStringConcatenation();
				break;
			default:
				throw new UnsupportedOperationException("Unsupported binary operator: " + operator);
		}

		return null;
	}

	@Override
	public Void visitUnaryExpression(UnaryExpression expr) {
		String operator = expr.getOperator();

		// Generate operand
		expr.getOperand().accept(this);

		switch (operator) {
			case "-":
				methodGenerator.visitInsn(INEG);
				break;
			case "+":
				// Unary plus is a no-op for integers
				break;
			case "!":
				generateLogicalNot();
				break;
			default:
				throw new UnsupportedOperationException("Unsupported unary operator: " + operator);
		}

		return null;
	}

	@Override
	public Void visitLiteralExpression(LiteralExpression expr) {
		Object value = expr.getValue();
		com.juno.types.Type astType = expr.getType();

		// Check if AST type indicates this should be a long value
		boolean shouldBeLong = (isLongType(astType));

		if (value instanceof Long) {
			long longValue = (Long) value;
			// Always generate proper long instructions for long literals
			if (longValue >= Integer.MIN_VALUE && longValue <= Integer.MAX_VALUE) {
				// Small long values: push as int and convert to long
				methodGenerator.visitLdcInsn((int) longValue);
				methodGenerator.visitInsn(I2L);
				jasminInstruction("ldc " + (int) longValue);
				jasminInstruction("i2l ; convert to long");
			}
			else {
				// Large long values: use ldc2_w
				methodGenerator.visitLdcInsn(longValue);
				jasminInstruction("ldc2_w " + longValue + "L");
			}
		}
		else if (value instanceof Integer) {
			int intValue = (Integer) value;

			if (intValue >= -128 && intValue <= 127) {
				methodGenerator.visitIntInsn(BIPUSH, intValue);
				jasminInstruction("bipush " + intValue);
			}
			else if (intValue >= -32768 && intValue <= 32767) {
				methodGenerator.visitIntInsn(SIPUSH, intValue);
				jasminInstruction("sipush " + intValue);
			}
			else {
				methodGenerator.visitLdcInsn(intValue);
				jasminInstruction("ldc " + intValue);
			}
			if (shouldBeLong) {
				/* Integer value but AST type is long - generate as int then convert
				 * int to long since AST type is long
				 */
				methodGenerator.visitInsn(I2L);
				jasminInstruction("i2l ; convert to long for AST type");
			}
			else {
				// Regular integer literal
			}
		}
		else if (value instanceof Float) {
			methodGenerator.visitLdcInsn(value);
			jasminInstruction("ldc " + value + "f");
		}
		else if (value instanceof Double) {
			methodGenerator.visitLdcInsn(value);
			jasminInstruction("ldc2_w " + value + "d");
		}
		else if (value instanceof String) {
			methodGenerator.visitLdcInsn(value);
			jasminInstruction("ldc \"" + value + "\"");
		}
		else if (value instanceof Boolean) {
			boolean boolValue = (Boolean) value;
			methodGenerator.visitIntInsn(BIPUSH, boolValue ? 1 : 0);
			jasminInstruction("bipush " + (boolValue ? "1" : "0"));
		}
		else if (value instanceof Character) {
			char charValue = (Character) value;
			methodGenerator.visitIntInsn(BIPUSH, charValue);
			jasminInstruction("bipush " + (int) charValue + " ; '" + charValue + "'");
		}
		else {
			throw new UnsupportedOperationException("Unsupported literal type: " + value.getClass());
		}

		return null;
	}

	@Override
	public Void visitIdentifierExpression(IdentifierExpression expr) {
		String varName = expr.getName();
		Integer slot = localVariables.get(varName);

		if (slot != null) {
			// Local variable - load from local slot
			com.juno.types.Type varType = expr.getType();
			loadVariable(varType, slot);
		}
		else if (globalVariables.containsKey(varName)) {
			// Global variable - load from static field
			com.juno.types.Type varType = globalVariables.get(varName);
			String fieldDescriptor = getJVMTypeDescriptor(varType);
			methodGenerator.visitFieldInsn(GETSTATIC, currentClassName, varName, fieldDescriptor);
		}
		else {
			throw new RuntimeException("Undefined variable: " + varName);
		}

		return null;
	}

	@Override
	public Void visitAssignmentExpression(AssignmentExpression expr) {
		if (!(expr.getTarget() instanceof IdentifierExpression target)) {
			throw new UnsupportedOperationException("Only simple variable assignment supported");
		}

		String varName = target.getName();
		Integer slot = localVariables.get(varName);

		if (slot == null) {
			throw new RuntimeException("Undefined variable: " + varName);
		}

		// Generate value
		expr.getValue().accept(this);

		// Get the target variable's type for type conversion
		com.juno.types.Type targetVarType = target.getType();
		com.juno.types.Type valueType = expr.getValue().getType();

		// Add type conversion if needed between value and target variable
		if (valueType != null && targetVarType != null && !valueType.equals(targetVarType)) {
			jasminComment("Convert " + valueType.getName() + " to " + targetVarType.getName() + " for assignment");
			generateTypeConversion(valueType, targetVarType);
		}

		// Duplicate value on stack (assignment returns the assigned value)
		methodGenerator.visitInsn(DUP);

		// Store in variable using target variable's type
		storeVariable(targetVarType, slot);

		return null;
	}

	@Override
	public Void visitCallExpression(CallExpression expr) {
		Expression function = expr.getFunction();
		String functionName;

		// Extract function name - support both simple and qualified calls
		if (function instanceof IdentifierExpression) {
			functionName = ((IdentifierExpression) function).getName();
		}
		else if (function instanceof QualifiedIdentifier qualId) {
			if ("Io".equals(qualId.getModuleName())) {
				generateIoCall(qualId.getIdentifier(), expr.getArguments());
				return null;
			}
			throw new UnsupportedOperationException("Unsupported qualified call: " + qualId.getFullName());
		}
		else {
			throw new UnsupportedOperationException("Only simple function calls supported: " + function.getClass());
		}

		// Generate arguments
		for (Expression arg : expr.getArguments()) {
			arg.accept(this);
		}

		// For now, assume all functions are static methods in the same class
		// TODO: Handle function signatures properly
		String methodDescriptor = buildFunctionCallDescriptor(expr);
		methodGenerator.visitMethodInsn(INVOKESTATIC, currentClassName, functionName, methodDescriptor, false);
		jasminInstruction("invokestatic " + currentClassName + "/" + functionName + methodDescriptor);

		return null;
	}

	@Override
	public Void visitQualifiedIdentifier(QualifiedIdentifier expr) {
		// Handle runtime module calls
		if ("Io".equals(expr.getModuleName())) {
			// This is handled in visitCallExpression for Io.function() calls
			return null;
		}

		throw new UnsupportedOperationException("Qualified identifiers not yet supported: " + expr.getFullName());
	}

	@Override
	public Void visitCastExpression(CastExpression expr) {
		com.juno.types.Type sourceType = expr.getExpression().getType();
		com.juno.types.Type targetType = expr.getTargetType();

		// Generate the expression to be cast
		expr.getExpression().accept(this);

		// Emit type conversion instructions
		generateTypeConversion(sourceType, targetType);

		return null;
	}

	@Override
	public Void visitArrayLiteralExpression(ArrayLiteralExpression expr) {
		ArrayType arrayType = (ArrayType) expr.getType();
		com.juno.types.Type elementType = arrayType.getElementType();
		int arraySize = expr.getElements().size();

		jasminComment("Array literal: " + arrayType.getName() + " with " + arraySize + " elements");

		// Push array size
		methodGenerator.visitIntInsn(BIPUSH, arraySize);
		jasminInstruction("bipush " + arraySize);

		// Create array of appropriate type
		String elementJvmType = getJVMTypeDescriptor(elementType);
		if (elementType instanceof PrimitiveType primType && !"string".equals(elementType.getName())) {
			int arrayTypeCode = getJVMArrayTypeCode(primType);
			methodGenerator.visitIntInsn(NEWARRAY, arrayTypeCode);
			jasminInstruction("newarray " + getJVMArrayTypeName(primType));
		}
		else {
			// Object array (including string arrays)
			String className = elementJvmType.startsWith("L") ?
					elementJvmType.substring(1, elementJvmType.length() - 1) : elementJvmType;
			methodGenerator.visitTypeInsn(ANEWARRAY, className);
			jasminInstruction("anewarray " + className);
		}

		// Fill array with elements
		for (int i = 0; i < arraySize; i++) {
			methodGenerator.visitInsn(DUP); // Duplicate array reference
			methodGenerator.visitIntInsn(BIPUSH, i); // Push index
			jasminInstruction("dup");
			jasminInstruction("bipush " + i);

			// Generate element value
			expr.getElements().get(i).accept(this);

			// Store in array
			generateArrayStore(elementType);
		}

		return null;
	}

	@Override
	public Void visitArrayIndexExpression(ArrayIndexExpression expr) {
		jasminComment("Array index access");

		// Generate array reference
		expr.getArray().accept(this);

		// Generate index
		expr.getIndex().accept(this);

		// Load from array
		com.juno.types.Type elementType = expr.getType();
		generateArrayLoad(elementType);

		return null;
	}

	@Override
	public Void visitAddressOfExpression(AddressOfExpression expr) {
		jasminComment("Address-of operator (&)");

		// In JVM, we implement pointers as objects that hold references
		// For now, we'll use a simple approach where &var creates a reference holder

		Expression operand = expr.getOperand();
		if (operand instanceof IdentifierExpression identExpr) {
			String varName = identExpr.getName();

			// Create a simple pointer object that holds the variable reference
			// This is a simplified implementation - in practice, we'd need a proper Pointer class
			Integer slot = localVariables.get(varName);
			if (slot != null) {
				// For local variables, store the slot number in the pointer object
				methodGenerator.visitIntInsn(BIPUSH, slot);
				jasminInstruction("bipush " + slot);

				// Create Integer wrapper for the slot reference
				methodGenerator.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer;", false);
				jasminInstruction("invokestatic java/lang/Integer/valueOf(I)Ljava/lang/Integer;");
			}
			else {
				throw new UnsupportedOperationException("Address-of for global variables not yet supported");
			}
		}
		else {
			throw new UnsupportedOperationException("Address-of only supported for simple identifiers currently");
		}

		return null;
	}

	@Override
	public Void visitDereferenceExpression(DereferenceExpression expr) {
		jasminComment("Dereference operator (*)");

		// Generate the pointer expression
		expr.getOperand().accept(this);

		// For our simplified implementation, the pointer holds a slot number as Integer
		// Cast to Integer and extract the slot
		methodGenerator.visitTypeInsn(CHECKCAST, "java/lang/Integer");
		methodGenerator.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false);
		jasminInstruction("checkcast java/lang/Integer");
		jasminInstruction("invokevirtual java/lang/Integer/intValue()I");

		// Now we have the slot number on the stack
		// For simplicity, we'll assume int type and generate iload with computed slot
		// This is a hack - in practice we'd need proper slot tracking
		throw new UnsupportedOperationException("Pointer dereference requires runtime slot loading - not yet implemented");
	}

	// ===== UTILITY METHODS =====

	private String buildMethodDescriptor(FunctionDeclaration funcDecl) {
		StringBuilder descriptor = new StringBuilder("(");

		// Parameter types
		for (FunctionDeclaration.Parameter param : funcDecl.parameters()) {
			descriptor.append(getJVMTypeDescriptor(param.type()));
		}

		descriptor.append(")");

		// Return type
		descriptor.append(getJVMTypeDescriptor(funcDecl.returnType()));

		return descriptor.toString();
	}

	private String buildFunctionCallDescriptor(CallExpression callExpr) {
		StringBuilder descriptor = new StringBuilder("(");

		// Parameter types (inferred from argument types)
		// TODO: This is a hack - we should look up the actual method signature
		for (Expression arg : callExpr.getArguments()) {
			com.juno.types.Type argType = arg.getType();

			// Most expressions produce int values on the JVM stack regardless of AST type
			// Only long-returning function calls actually produce long values
			if (isCallExpressionReturningLong(arg)) {
				descriptor.append("J"); // Function call returning long
			}
			else if (isLongType(argType) && isLongLiteralExpression(arg)) {
				descriptor.append("J"); // Large long literal that actually needs long
			}
			else {
				descriptor.append("I"); // Everything else produces int on JVM stack
			}
		}

		descriptor.append(")");

		// Return type (from the call expression's type)
		com.juno.types.Type returnType = callExpr.getType();
		descriptor.append(getJVMTypeDescriptor(returnType));

		return descriptor.toString();
	}

	private String getJVMTypeDescriptor(com.juno.types.Type type) {
		if (type instanceof PrimitiveType) {
			switch (type.getName()) {
				case "void":
					return "V";
				case "bool":
					return "Z";
				case "byte":
				case "ubyte":
				case "short":
				case "ushort":
				case "int":
				case "uint":
					return "I";  // Use int for all small integer types
				case "long":
				case "ulong":
					return "J";
				case "float":
					return "F";
				case "double":
					return "D";
				case "char":
					return "C";
				case "string":
					return "Ljava/lang/String;";
				default:
					throw new UnsupportedOperationException("Unsupported primitive type: " + type.getName());
			}
		}
		else if (type instanceof ArrayType) {
			return type.getJVMDescriptor();
		}
		else if (type instanceof UnionType) {
			// Union types are represented as tagged unions using Object
			return "Ljava/lang/Object;";
		}
		else {
			// For now, treat complex types as Object
			return "Ljava/lang/Object;";
		}
	}

	private int getTypeSize(com.juno.types.Type type) {
		if (type instanceof PrimitiveType) {
			switch (type.getName()) {
				case "long":
				case "ulong":
				case "double":
					return 2;  // 64-bit types take 2 slots
				default:
					return 1;  // All other types take 1 slot
			}
		}
		return 1;
	}

	private void loadVariable(com.juno.types.Type type, int slot) {
		if (type == null) {
			methodGenerator.visitVarInsn(ILOAD, slot);  // Default to int
			jasminInstruction("iload " + slot);
			return;
		}

		if (type instanceof PrimitiveType) {
			switch (type.getName()) {
				case "long":
				case "ulong":
					methodGenerator.visitVarInsn(LLOAD, slot);
					jasminInstruction("lload " + slot);
					break;
				case "float":
					methodGenerator.visitVarInsn(FLOAD, slot);
					jasminInstruction("fload " + slot);
					break;
				case "double":
					methodGenerator.visitVarInsn(DLOAD, slot);
					jasminInstruction("dload " + slot);
					break;
				case "string":
					methodGenerator.visitVarInsn(ALOAD, slot);
					jasminInstruction("aload " + slot);
					break;
				default:
					methodGenerator.visitVarInsn(ILOAD, slot);
					jasminInstruction("iload " + slot);
			}
		}
		else if (type instanceof UnionType) {
			// Union types are stored as Object references
			methodGenerator.visitVarInsn(ALOAD, slot);
			jasminInstruction("aload " + slot + " ; union type");
		}
		else {
			methodGenerator.visitVarInsn(ALOAD, slot);  // Object reference
			jasminInstruction("aload " + slot);
		}
	}

	private void storeVariable(com.juno.types.Type type, int slot) {
		if (type == null) {
			methodGenerator.visitVarInsn(ISTORE, slot);  // Default to int
			jasminInstruction("istore " + slot);
			return;
		}

		if (type instanceof PrimitiveType) {
			switch (type.getName()) {
				case "bool":
				case "byte":
				case "ubyte":
				case "short":
				case "ushort":
				case "int":
				case "uint":
				case "char":
					methodGenerator.visitVarInsn(ISTORE, slot);
					jasminInstruction("istore " + slot);
					break;
				case "long":
				case "ulong":
					methodGenerator.visitVarInsn(LSTORE, slot);
					jasminInstruction("lstore " + slot);
					break;
				case "float":
					methodGenerator.visitVarInsn(FSTORE, slot);
					jasminInstruction("fstore " + slot);
					break;
				case "double":
					methodGenerator.visitVarInsn(DSTORE, slot);
					jasminInstruction("dstore " + slot);
					break;
				case "string":
					methodGenerator.visitVarInsn(ASTORE, slot);
					jasminInstruction("astore " + slot);
					break;
				default:
					methodGenerator.visitVarInsn(ISTORE, slot);
					jasminInstruction("istore " + slot);
			}
		}
		else if (type instanceof UnionType) {
			// Union types are stored as Object references
			methodGenerator.visitVarInsn(ASTORE, slot);
			jasminInstruction("astore " + slot + " ; union type");
		}
		else {
			methodGenerator.visitVarInsn(ASTORE, slot);  // Object reference
			jasminInstruction("astore " + slot);
		}
	}

	private void generateDefaultValue(com.juno.types.Type type) {
		if (type instanceof PrimitiveType) {
			switch (type.getName()) {
				case "bool":
				case "byte":
				case "ubyte":
				case "short":
				case "ushort":
				case "int":
				case "uint":
				case "char":
					methodGenerator.visitInsn(ICONST_0);
					break;
				case "long":
				case "ulong":
					methodGenerator.visitInsn(LCONST_0);
					break;
				case "float":
					methodGenerator.visitInsn(FCONST_0);
					break;
				case "double":
					methodGenerator.visitInsn(DCONST_0);
					break;
				case "string":
					methodGenerator.visitInsn(ACONST_NULL);
					break;
				default:
					methodGenerator.visitInsn(ICONST_0);
			}
		}
		else if (type instanceof UnionType) {
			// Union types default to null
			methodGenerator.visitInsn(ACONST_NULL);
		}
		else {
			methodGenerator.visitInsn(ACONST_NULL);
		}
	}

	private void generateReturn(com.juno.types.Type returnType) {
		if (returnType instanceof PrimitiveType) {
			switch (returnType.getName()) {
				case "void":
					methodGenerator.visitInsn(RETURN);
					jasminInstruction("return");
					break;
				case "bool":
				case "byte":
				case "ubyte":
				case "short":
				case "ushort":
				case "int":
				case "uint":
				case "char":
					methodGenerator.visitInsn(IRETURN);
					jasminInstruction("ireturn");
					break;
				case "long":
				case "ulong":
					methodGenerator.visitInsn(LRETURN);
					jasminInstruction("lreturn");
					break;
				case "float":
					methodGenerator.visitInsn(FRETURN);
					jasminInstruction("freturn");
					break;
				case "double":
					methodGenerator.visitInsn(DRETURN);
					jasminInstruction("dreturn");
					break;
				case "string":
					methodGenerator.visitInsn(ARETURN);
					jasminInstruction("areturn");
					break;
				default:
					methodGenerator.visitInsn(IRETURN);
					jasminInstruction("ireturn");
			}
		}
		else {
			methodGenerator.visitInsn(ARETURN);
			jasminInstruction("areturn");
		}
	}

	private void generateComparison(int compareOpcode) {
		Label trueLabel = methodGenerator.newLabel();
		Label endLabel = methodGenerator.newLabel();
		int trueLabelId = ++labelCounter;
		int endLabelId = ++labelCounter;

		// Compare and jump to true label if condition holds
		methodGenerator.visitJumpInsn(compareOpcode, trueLabel);
		String jumpInstr = getJumpInstructionName(compareOpcode);
		jasminInstruction(jumpInstr + " true_" + trueLabelId);

		// False case: push 0
		methodGenerator.visitInsn(ICONST_0);
		jasminInstruction("iconst_0");
		methodGenerator.visitJumpInsn(GOTO, endLabel);
		jasminInstruction("goto end_" + endLabelId);

		// True case: push 1
		methodGenerator.visitLabel(trueLabel);
		jasminLabel("true_" + trueLabelId);
		methodGenerator.visitInsn(ICONST_1);
		jasminInstruction("iconst_1");

		methodGenerator.visitLabel(endLabel);
		jasminLabel("end_" + endLabelId);
	}

	private void generateLogicalNot() {
		Label trueLabel = methodGenerator.newLabel();
		Label endLabel = methodGenerator.newLabel();

		// If value is 0 (false), jump to true label
		methodGenerator.visitJumpInsn(IFEQ, trueLabel);

		// Value was non-zero (true), so result is false (0)
		methodGenerator.visitInsn(ICONST_0);
		methodGenerator.visitJumpInsn(GOTO, endLabel);

		// Value was zero (false), so result is true (1)
		methodGenerator.visitLabel(trueLabel);
		methodGenerator.visitInsn(ICONST_1);

		methodGenerator.visitLabel(endLabel);
	}

	private void generateLogicalAnd() {
		Label falseLabel = methodGenerator.newLabel();
		Label endLabel = methodGenerator.newLabel();

		// Left operand is already on stack
		// Duplicate it for the test
		methodGenerator.visitInsn(DUP);
		methodGenerator.visitJumpInsn(IFEQ, falseLabel);  // If left is false, short-circuit

		// Left was true, pop it and use right operand result
		methodGenerator.visitInsn(POP);
		// Right operand is already on stack
		methodGenerator.visitJumpInsn(GOTO, endLabel);

		// Left was false, pop right operand and push false
		methodGenerator.visitLabel(falseLabel);
		methodGenerator.visitInsn(POP);  // Pop right operand
		methodGenerator.visitInsn(ICONST_0);

		methodGenerator.visitLabel(endLabel);
	}

	private void generateLogicalOr() {
		Label trueLabel = methodGenerator.newLabel();
		Label endLabel = methodGenerator.newLabel();

		// Left operand is already on stack
		// Duplicate it for the test
		methodGenerator.visitInsn(DUP);
		methodGenerator.visitJumpInsn(IFNE, trueLabel);  // If left is true, short-circuit

		// Left was false, pop it and use right operand result
		methodGenerator.visitInsn(POP);
		// Right operand is already on stack
		methodGenerator.visitJumpInsn(GOTO, endLabel);

		// Left was true, pop right operand and push true
		methodGenerator.visitLabel(trueLabel);
		methodGenerator.visitInsn(POP);  // Pop right operand
		methodGenerator.visitInsn(ICONST_1);

		methodGenerator.visitLabel(endLabel);
	}

	private void generateStringConcatenation() {
		// At this point, stack has: [left_operand, right_operand]
		// We need to convert both to strings and concatenate left + right

		// Store right operand temporarily
		methodGenerator.visitInsn(SWAP);  // [right, left]
		jasminInstruction("swap");

		// Convert left operand to string
		methodGenerator.visitMethodInsn(INVOKESTATIC, "java/lang/String", "valueOf", "(Ljava/lang/Object;)Ljava/lang/String;", false);
		jasminInstruction("invokestatic java/lang/String/valueOf(Ljava/lang/Object;)Ljava/lang/String;");
		// Stack: [right, left_string]

		methodGenerator.visitInsn(SWAP);  // [left_string, right]
		jasminInstruction("swap");

		// Convert right operand to string
		methodGenerator.visitMethodInsn(INVOKESTATIC, "java/lang/String", "valueOf", "(Ljava/lang/Object;)Ljava/lang/String;", false);
		jasminInstruction("invokestatic java/lang/String/valueOf(Ljava/lang/Object;)Ljava/lang/String;");
		// Stack: [left_string, right_string]

		// Concatenate strings: left.concat(right)
		methodGenerator.visitMethodInsn(INVOKEVIRTUAL, "java/lang/String", "concat", "(Ljava/lang/String;)Ljava/lang/String;", false);
		jasminInstruction("invokevirtual java/lang/String/concat(Ljava/lang/String;)Ljava/lang/String;");
	}

	private void generateIoCall(String function, java.util.List<Expression> arguments) {
		// Generate arguments
		for (Expression arg : arguments) {
			arg.accept(this);
		}

		// Map to runtime calls
		String descriptor;
		switch (function) {
			case "print":
			case "println":
			case "report":
				descriptor = "(Ljava/lang/String;)V";
				break;
			case "scan":
				descriptor = "()Ljava/lang/String;";
				break;
			default:
				throw new UnsupportedOperationException("Unknown Io function: " + function);
		}

		methodGenerator.visitMethodInsn(INVOKESTATIC, "com/juno/runtime/Io", function, descriptor, false);
		jasminInstruction("invokestatic com/juno/runtime/Io/" + function + descriptor);
	}

	private String getJumpInstructionName(int opcode) {
		switch (opcode) {
			case IF_ICMPEQ:
				return "if_icmpeq";
			case IF_ICMPNE:
				return "if_icmpne";
			case IF_ICMPLT:
				return "if_icmplt";
			case IF_ICMPLE:
				return "if_icmple";
			case IF_ICMPGT:
				return "if_icmpgt";
			case IF_ICMPGE:
				return "if_icmpge";
			default:
				return "if_icmp_unknown";
		}
	}

	// ===== TYPE CONVERSION METHODS =====

	private boolean needsTypeConversion(com.juno.types.Type fromType, com.juno.types.Type toType) {
		if (fromType == null || toType == null) {
			return false;
		}

		// If types are the same, no conversion needed
		if (fromType.getName().equals(toType.getName())) {
			return false;
		}

		// Check if conversion from int to long is needed (common case for literals)
		return isIntegerType(fromType) && isLongType(toType);

		// Add more conversion rules as needed
	}

	/**
	 * Generate JVM bytecode instructions to convert from one type to another.
	 * Assumes the source value is already on the stack.
	 */
	private void generateTypeConversion(com.juno.types.Type fromType, com.juno.types.Type toType) {
		if (fromType == null || toType == null) {
			return; // No conversion possible
		}

		// If types are the same, no conversion needed
		String fromTypeName = fromType.getName();
		String toTypeName = toType.getName();

		if (fromTypeName.equals(toTypeName)) {
			return; // No conversion needed
		}

		// Handle conversions TO union types (boxing)
		if (toType instanceof UnionType) {
			generatePrimitiveToUnionConversion(fromType, (UnionType) toType);
		}
		// Handle primitive to string conversions
		else if (fromType instanceof PrimitiveType && "string".equals(toTypeName)) {
			generatePrimitiveToStringConversion(fromTypeName);
		}
		// Handle primitive type conversions
		else if (fromType instanceof PrimitiveType && toType instanceof PrimitiveType) {
			generatePrimitiveTypeConversion(fromTypeName, toTypeName);
		}
		else {
			// For non-primitive types, assume no conversion is needed for now
			// TODO: Handle object type conversions, boxing/unboxing
		}
	}

	/**
	 * Generate conversion instructions for primitive types.
	 */
	private void generatePrimitiveTypeConversion(String fromTypeName, String toTypeName) {
		// Handle integer to integer conversions
		if (isIntegerTypeName(fromTypeName) && isIntegerTypeName(toTypeName)) {
			generateIntegerToIntegerConversion(fromTypeName, toTypeName);
		}
		// Handle integer to floating point conversions
		else if (isIntegerTypeName(fromTypeName) && isFloatingPointTypeName(toTypeName)) {
			generateIntegerToFloatConversion(fromTypeName, toTypeName);
		}
		// Handle floating point to integer conversions
		else if (isFloatingPointTypeName(fromTypeName) && isIntegerTypeName(toTypeName)) {
			generateFloatToIntegerConversion(fromTypeName, toTypeName);
		}
		// Handle floating point to floating point conversions
		else if (isFloatingPointTypeName(fromTypeName) && isFloatingPointTypeName(toTypeName)) {
			generateFloatToFloatConversion(fromTypeName, toTypeName);
		}
		// Handle character conversions
		else if ("char".equals(fromTypeName) && isIntegerTypeName(toTypeName)) {
			// char -> integer (char is already stored as int in JVM)
			if ("long".equals(toTypeName) || "ulong".equals(toTypeName)) {
				methodGenerator.visitInsn(I2L);
				jasminInstruction("i2l ; char to long");
			}
			// For other integer types, no conversion needed (char is already int on JVM)
		}
		else if (isIntegerTypeName(fromTypeName) && "char".equals(toTypeName)) {
			// integer -> char (truncate to char range)
			if ("long".equals(fromTypeName) || "ulong".equals(fromTypeName)) {
				methodGenerator.visitInsn(L2I);
				jasminInstruction("l2i ; long to char via int");
			}
			// For other integer types, no conversion needed (already int on JVM)
		}
		// Handle bool conversions
		else if ("bool".equals(fromTypeName) && isIntegerTypeName(toTypeName)) {
			if ("long".equals(toTypeName) || "ulong".equals(toTypeName)) {
				methodGenerator.visitInsn(I2L);
				jasminInstruction("i2l ; bool to long");
			}
			// For other integer types, no conversion needed (bool is already int on JVM)
		}
		else if (isIntegerTypeName(fromTypeName) && "bool".equals(toTypeName)) {
			if ("long".equals(fromTypeName) || "ulong".equals(fromTypeName)) {
				methodGenerator.visitInsn(L2I);
				jasminInstruction("l2i ; long to bool via int");
			}
			// TODO: Consider adding bounds checking for bool conversion (ensure 0 or 1)
		}
	}

	private void generateIntegerToIntegerConversion(String fromTypeName, String toTypeName) {
		// From smaller integer types to long
		if (("int".equals(fromTypeName) || "uint".equals(fromTypeName) ||
				"byte".equals(fromTypeName) || "ubyte".equals(fromTypeName) ||
				"short".equals(fromTypeName) || "ushort".equals(fromTypeName)) &&
				("long".equals(toTypeName) || "ulong".equals(toTypeName))) {
			methodGenerator.visitInsn(I2L);
			jasminInstruction("i2l ; " + fromTypeName + " to " + toTypeName);
		}
		// From long to smaller integer types
		else if (("long".equals(fromTypeName) || "ulong".equals(fromTypeName)) &&
				("int".equals(toTypeName) || "uint".equals(toTypeName) ||
						"byte".equals(toTypeName) || "ubyte".equals(toTypeName) ||
						"short".equals(toTypeName) || "ushort".equals(toTypeName))) {
			methodGenerator.visitInsn(L2I);
			jasminInstruction("l2i ; " + fromTypeName + " to " + toTypeName);

			// Additional narrowing if needed
			if ("byte".equals(toTypeName) || "ubyte".equals(toTypeName)) {
				methodGenerator.visitInsn(I2B);
				jasminInstruction("i2b ; narrow to byte");
			}
			else if ("short".equals(toTypeName) || "ushort".equals(toTypeName)) {
				methodGenerator.visitInsn(I2S);
				jasminInstruction("i2s ; narrow to short");
			}
		}
		// From int to smaller integer types (byte, short)
		else if (("int".equals(fromTypeName) || "uint".equals(fromTypeName)) &&
				("byte".equals(toTypeName) || "ubyte".equals(toTypeName))) {
			methodGenerator.visitInsn(I2B);
			jasminInstruction("i2b ; " + fromTypeName + " to " + toTypeName);
		}
		else if (("int".equals(fromTypeName) || "uint".equals(fromTypeName)) &&
				("short".equals(toTypeName) || "ushort".equals(toTypeName))) {
			methodGenerator.visitInsn(I2S);
			jasminInstruction("i2s ; " + fromTypeName + " to " + toTypeName);
		}
		// No conversion needed for same-sized integer types (int/uint, long/ulong, etc.)
	}

	private void generateIntegerToFloatConversion(String fromTypeName, String toTypeName) {
		if ("long".equals(fromTypeName) || "ulong".equals(fromTypeName)) {
			if ("float".equals(toTypeName)) {
				methodGenerator.visitInsn(L2F);
				jasminInstruction("l2f ; " + fromTypeName + " to float");
			}
			else if ("double".equals(toTypeName)) {
				methodGenerator.visitInsn(L2D);
				jasminInstruction("l2d ; " + fromTypeName + " to double");
			}
		}
		else {
			// From int-sized types to float
			if ("float".equals(toTypeName)) {
				methodGenerator.visitInsn(I2F);
				jasminInstruction("i2f ; " + fromTypeName + " to float");
			}
			else if ("double".equals(toTypeName)) {
				methodGenerator.visitInsn(I2D);
				jasminInstruction("i2d ; " + fromTypeName + " to double");
			}
		}
	}

	private void generateFloatToIntegerConversion(String fromTypeName, String toTypeName) {
		// First convert to int or long
		if ("float".equals(fromTypeName)) {
			if ("long".equals(toTypeName) || "ulong".equals(toTypeName)) {
				methodGenerator.visitInsn(F2L);
				jasminInstruction("f2l ; float to " + toTypeName);
			}
			else {
				methodGenerator.visitInsn(F2I);
				jasminInstruction("f2i ; float to " + toTypeName);

				// Additional narrowing if needed
				if ("byte".equals(toTypeName) || "ubyte".equals(toTypeName)) {
					methodGenerator.visitInsn(I2B);
					jasminInstruction("i2b ; narrow to byte");
				}
				else if ("short".equals(toTypeName) || "ushort".equals(toTypeName)) {
					methodGenerator.visitInsn(I2S);
					jasminInstruction("i2s ; narrow to short");
				}
			}
		}
		else if ("double".equals(fromTypeName)) {
			if ("long".equals(toTypeName) || "ulong".equals(toTypeName)) {
				methodGenerator.visitInsn(D2L);
				jasminInstruction("d2l ; double to " + toTypeName);
			}
			else {
				methodGenerator.visitInsn(D2I);
				jasminInstruction("d2i ; double to " + toTypeName);

				// Additional narrowing if needed
				if ("byte".equals(toTypeName) || "ubyte".equals(toTypeName)) {
					methodGenerator.visitInsn(I2B);
					jasminInstruction("i2b ; narrow to byte");
				}
				else if ("short".equals(toTypeName) || "ushort".equals(toTypeName)) {
					methodGenerator.visitInsn(I2S);
					jasminInstruction("i2s ; narrow to short");
				}
			}
		}
	}

	private void generateFloatToFloatConversion(String fromTypeName, String toTypeName) {
		if ("float".equals(fromTypeName) && "double".equals(toTypeName)) {
			methodGenerator.visitInsn(F2D);
			jasminInstruction("f2d ; float to double");
		}
		else if ("double".equals(fromTypeName) && "float".equals(toTypeName)) {
			methodGenerator.visitInsn(D2F);
			jasminInstruction("d2f ; double to float");
		}
	}

	/**
	 * Generate conversion from primitive types to union types.
	 * For now, this is a simple boxing operation - we just wrap the primitive in an Object.
	 * In a full implementation, this would create a tagged union object.
	 */
	private void generatePrimitiveToUnionConversion(com.juno.types.Type fromType, UnionType toType) {
		// For now, we use primitive boxing to convert to Object
		// This is a simplified approach - a full union type would need runtime type tags

		if (fromType instanceof PrimitiveType) {
			String fromTypeName = fromType.getName();

			// Box primitives to their wrapper types
			switch (fromTypeName) {
				case "int":
				case "uint":
					methodGenerator.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer;", false);
					jasminInstruction("invokestatic java/lang/Integer/valueOf(I)Ljava/lang/Integer; ; box int to union");
					break;
				case "long":
				case "ulong":
					methodGenerator.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long;", false);
					jasminInstruction("invokestatic java/lang/Long/valueOf(J)Ljava/lang/Long; ; box long to union");
					break;
				case "float":
					methodGenerator.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float;", false);
					jasminInstruction("invokestatic java/lang/Float/valueOf(F)Ljava/lang/Float; ; box float to union");
					break;
				case "double":
					methodGenerator.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double;", false);
					jasminInstruction("invokestatic java/lang/Double/valueOf(D)Ljava/lang/Double; ; box double to union");
					break;
				case "bool":
					methodGenerator.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean;", false);
					jasminInstruction("invokestatic java/lang/Boolean/valueOf(Z)Ljava/lang/Boolean; ; box bool to union");
					break;
				case "char":
					methodGenerator.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character;", false);
					jasminInstruction("invokestatic java/lang/Character/valueOf(C)Ljava/lang/Character; ; box char to union");
					break;
				case "byte":
				case "ubyte":
				case "short":
				case "ushort":
					// These are stored as int on JVM, so box as Integer
					methodGenerator.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer;", false);
					jasminInstruction("invokestatic java/lang/Integer/valueOf(I)Ljava/lang/Integer; ; box " + fromTypeName + " to union");
					break;
				case "string":
					// String is already an Object, no boxing needed
					jasminComment("String already Object for union type");
					break;
				default:
					jasminComment("Unknown primitive type for union conversion: " + fromTypeName);
					break;
			}
		}
		else {
			// Non-primitive types are already Objects
			jasminComment("Non-primitive type already Object for union");
		}
	}

	/**
	 * Generate conversion from primitive types to string using String.valueOf().
	 * Assumes the primitive value is already on the stack.
	 */
	private void generatePrimitiveToStringConversion(String fromTypeName) {
		// Use appropriate String.valueOf method based on the primitive type
		String descriptor;

		if ("long".equals(fromTypeName) || "ulong".equals(fromTypeName)) {
			descriptor = "(J)Ljava/lang/String;";
		}
		else if ("float".equals(fromTypeName)) {
			descriptor = "(F)Ljava/lang/String;";
		}
		else if ("double".equals(fromTypeName)) {
			descriptor = "(D)Ljava/lang/String;";
		}
		else if ("bool".equals(fromTypeName)) {
			descriptor = "(Z)Ljava/lang/String;";
		}
		else if ("char".equals(fromTypeName)) {
			descriptor = "(C)Ljava/lang/String;";
		}
		else {
			// For int-sized types (int, uint, short, ushort, byte, ubyte)
			// All are represented as int on JVM stack
			descriptor = "(I)Ljava/lang/String;";
		}

		methodGenerator.visitMethodInsn(INVOKESTATIC, "java/lang/String", "valueOf", descriptor, false);
		jasminInstruction("invokestatic java/lang/String/valueOf" + descriptor + " ; " + fromTypeName + " to string");
	}

	private boolean isIntegerTypeName(String typeName) {
		return "int".equals(typeName) || "uint".equals(typeName) ||
				"long".equals(typeName) || "ulong".equals(typeName) ||
				"byte".equals(typeName) || "ubyte".equals(typeName) ||
				"short".equals(typeName) || "ushort".equals(typeName);
	}

	private boolean isFloatingPointTypeName(String typeName) {
		return "float".equals(typeName) || "double".equals(typeName);
	}

	private boolean isIntegerType(com.juno.types.Type type) {
		if (!(type instanceof PrimitiveType)) {
			return false;
		}
		String typeName = type.getName();
		return typeName.equals("int") || typeName.equals("uint") ||
				typeName.equals("byte") || typeName.equals("ubyte") ||
				typeName.equals("short") || typeName.equals("ushort");
	}

	private boolean isLongType(com.juno.types.Type type) {
		if (!(type instanceof PrimitiveType)) {
			return false;
		}
		String typeName = type.getName();
		return typeName.equals("long") || typeName.equals("ulong");
	}

	private boolean isCallExpressionReturningLong(Expression expr) {
		// Check if this expression is a function call that returns a long type
		if (expr instanceof CallExpression callExpr) {
			com.juno.types.Type returnType = callExpr.getType();
			return isLongType(returnType);
		}
		return false;
	}

	private boolean isLongLiteralExpression(Expression expr) {
		// Check if this is a literal that actually needs to be represented as long
		if (expr instanceof LiteralExpression litExpr) {
			Object value = litExpr.getValue();
			if (value instanceof Long) {
				long longValue = (Long) value;
				// Only use long descriptor for values that don't fit in int
				return longValue < Integer.MIN_VALUE || longValue > Integer.MAX_VALUE;
			}
		}
		return false;
	}

	private boolean isLongArithmetic(Expression left, Expression right) {
		// Use long arithmetic if either operand produces a long value on the stack
		return producesLongValue(left) || producesLongValue(right);
	}

	private boolean producesLongValue(Expression expr) {
		// Check if this expression produces a long value on the JVM stack
		return isCallExpressionReturningLong(expr) || isLongLiteralExpression(expr);
	}

	private boolean isLongArithmeticExpression(Expression expr) {
		// Check if this is a binary expression that uses long arithmetic
		if (expr instanceof BinaryExpression binExpr) {
			String operator = binExpr.getOperator();
			// Check if it's an arithmetic operator that can produce long results
			if ("+".equals(operator) || "-".equals(operator) ||
					"*".equals(operator) || "/".equals(operator) || "%".equals(operator)) {
				return isLongArithmetic(binExpr.getLeft(), binExpr.getRight());
			}
		}
		return false;
	}

	// ===== JASMIN ASSEMBLY GENERATION =====

	private void generateJasminHeader(String className) {
		jasminOutput.append(".class public ").append(className).append("\n");
		jasminOutput.append(".super java/lang/Object\n\n");

		// Generate default constructor
		jasminOutput.append(".method public <init>()V\n");
		jasminOutput.append("    .limit stack 1\n");
		jasminOutput.append("    .limit locals 1\n");
		jasminOutput.append("    aload_0\n");
		jasminOutput.append("    invokespecial java/lang/Object/<init>()V\n");
		jasminOutput.append("    return\n");
		jasminOutput.append(".end method\n\n");
	}

	private void jasminComment(String comment) {
		jasminOutput.append("; ").append(comment).append("\n");
	}

	private void jasminInstruction(String instruction) {
		jasminOutput.append("    ").append(instruction).append("\n");
	}

	private void jasminLabel(String label) {
		jasminOutput.append(label).append(":\n");
	}

	private void jasminDirective(String directive) {
		jasminOutput.append(directive).append("\n");
	}

	private void jasminMethod(String signature, String access) {
		jasminOutput.append(".method ").append(access).append(" ").append(signature).append("\n");
	}

	private void jasminEndMethod() {
		jasminOutput.append(".end method\n\n");
	}

	private void jasminField(String name, String descriptor, String access) {
		jasminOutput.append(".field ").append(access).append(" ")
				.append(name).append(" ").append(descriptor).append("\n");
	}

	private void generateStaticInitializer() {
		if (globalInitializers.isEmpty()) {
			return; // No initialization needed
		}

		// Create static initializer method <clinit>
		MethodVisitor clinit = classWriter.visitMethod(ACC_STATIC, "<clinit>", "()V", null, null);
		methodGenerator = new GeneratorAdapter(ACC_STATIC, new Method("<clinit>", "()V"), clinit);

		// Generate Jasmin static initializer
		jasminComment("Static initializer for global variables");
		jasminMethod("<clinit>()V", "static");
		jasminDirective("    .limit stack 10");
		jasminDirective("    .limit locals 1");

		methodGenerator.visitCode();

		// Initialize each global variable with its initializer
		for (String varName : globalInitializers.keySet()) {
			Expression initializer = globalInitializers.get(varName);
			com.juno.types.Type varType = globalVariables.get(varName);

			jasminComment("Initialize " + varName);

			// Generate initialization value
			initializer.accept(this);

			// Add type conversion if needed
			if (varType instanceof PrimitiveType && varType.getName().equals("float") &&
					initializer instanceof LiteralExpression) {
				Object value = ((LiteralExpression) initializer).getValue();
				if (value instanceof Double) {
					// Convert double to float on the stack
					methodGenerator.visitInsn(D2F);
					jasminInstruction("d2f");
				}
			}

			// Store in static field
			String fieldDescriptor = getJVMTypeDescriptor(varType);
			methodGenerator.visitFieldInsn(PUTSTATIC, currentClassName, varName, fieldDescriptor);
		}

		// Return from static initializer
		methodGenerator.visitInsn(RETURN);
		methodGenerator.visitMaxs(0, 0);
		methodGenerator.visitEnd();

		// End Jasmin static initializer
		jasminInstruction("return");
		jasminEndMethod();

		// Clear method generator
		methodGenerator = null;
	}

	private void generateJvmMainMethod() {
		if (!hasJunoMainMethod) {
			return; // No Juno main method to wrap
		}

		// Create JVM-compatible main method: public static void main(String[] args)
		MethodVisitor mainMethod = classWriter.visitMethod(
				ACC_PUBLIC | ACC_STATIC,
				"main",
				"([Ljava/lang/String;)V",
				null,
				null
		);

		methodGenerator = new GeneratorAdapter(ACC_PUBLIC | ACC_STATIC,
																					 new Method("main", "([Ljava/lang/String;)V"), mainMethod);

		// Generate Jasmin JVM main method
		jasminComment("JVM-compatible main method wrapper");
		jasminMethod("main([Ljava/lang/String;)V", "public static");
		jasminDirective("    .limit stack 10");
		jasminDirective("    .limit locals 1");

		methodGenerator.visitCode();

		// Determine the return type of Juno main
		boolean isVoidMain = junoMainReturnType != null && junoMainReturnType.getName().equals("void");
		boolean isLongMain = isLongType(junoMainReturnType);

		String callDescriptor;
		if (isVoidMain) {
			callDescriptor = "()V";
		}
		else if (isLongMain) {
			callDescriptor = "()J";
		}
		else {
			callDescriptor = "()I";
		}

		// Call our Juno main() method
		methodGenerator.visitMethodInsn(INVOKESTATIC, currentClassName, "main", callDescriptor, false);
		jasminInstruction("invokestatic " + currentClassName + "/main" + callDescriptor);

		// If main returns a value, print it to stdout (standard JVM behavior)
		if (!isVoidMain) {
			String printDescriptor = isLongMain ? "(J)V" : "(I)V";

			// Get System.out for printing
			methodGenerator.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
			jasminInstruction("getstatic java/lang/System/out Ljava/io/PrintStream;");

			if (isLongMain) {
				// For long values: stack is [long_low, long_high, PrintStream]
				// We need: [PrintStream, long_low, long_high]
				// Use DUP_X2 then POP to reorder
				methodGenerator.visitInsn(DUP_X2);  // [PrintStream, long_low, long_high, PrintStream]
				methodGenerator.visitInsn(POP);     // [PrintStream, long_low, long_high]
				jasminInstruction("dup_x2");
				jasminInstruction("pop");
			}
			else {
				methodGenerator.visitInsn(SWAP);  // Put int result before PrintStream
				jasminInstruction("swap");
			}

			methodGenerator.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", printDescriptor, false);
			jasminInstruction("invokevirtual java/io/PrintStream/println" + printDescriptor);
		}

		// Return void (standard JVM main behavior)
		methodGenerator.visitInsn(RETURN);
		jasminInstruction("return");

		methodGenerator.visitMaxs(0, 0);
		methodGenerator.visitEnd();

		// End Jasmin JVM main method
		jasminEndMethod();

		// Clear method generator
		methodGenerator = null;
	}

	// ===== ARRAY HELPER METHODS =====

	/**
	 * Get JVM array type code for primitive types used with NEWARRAY instruction.
	 */
	private int getJVMArrayTypeCode(PrimitiveType primType) {
		switch (primType.getName()) {
			case "bool":
				return T_BOOLEAN;
			case "byte":
			case "ubyte":
				return T_BYTE;
			case "short":
			case "ushort":
				return T_SHORT;
			case "int":
			case "uint":
				return T_INT;
			case "long":
			case "ulong":
				return T_LONG;
			case "float":
				return T_FLOAT;
			case "double":
				return T_DOUBLE;
			case "char":
				return T_CHAR;
			default:
				throw new UnsupportedOperationException("Unsupported primitive array type: " + primType.getName());
		}
	}

	/**
	 * Get JVM array type name for Jasmin assembly.
	 */
	private String getJVMArrayTypeName(PrimitiveType primType) {
		switch (primType.getName()) {
			case "bool":
				return "boolean";
			case "byte":
			case "ubyte":
				return "byte";
			case "short":
			case "ushort":
				return "short";
			case "int":
			case "uint":
				return "int";
			case "long":
			case "ulong":
				return "long";
			case "float":
				return "float";
			case "double":
				return "double";
			case "char":
				return "char";
			default:
				throw new UnsupportedOperationException("Unsupported primitive array type: " + primType.getName());
		}
	}

	/**
	 * Generate array store instruction based on element type.
	 */
	private void generateArrayStore(com.juno.types.Type elementType) {
		if (elementType instanceof PrimitiveType primType) {
			switch (primType.getName()) {
				case "bool":
					methodGenerator.visitInsn(BASTORE); // boolean uses byte array operations
					jasminInstruction("bastore");
					break;
				case "byte":
				case "ubyte":
					methodGenerator.visitInsn(BASTORE);
					jasminInstruction("bastore");
					break;
				case "short":
				case "ushort":
					methodGenerator.visitInsn(SASTORE);
					jasminInstruction("sastore");
					break;
				case "int":
				case "uint":
					methodGenerator.visitInsn(IASTORE);
					jasminInstruction("iastore");
					break;
				case "long":
				case "ulong":
					methodGenerator.visitInsn(LASTORE);
					jasminInstruction("lastore");
					break;
				case "float":
					methodGenerator.visitInsn(FASTORE);
					jasminInstruction("fastore");
					break;
				case "double":
					methodGenerator.visitInsn(DASTORE);
					jasminInstruction("dastore");
					break;
				case "char":
					methodGenerator.visitInsn(CASTORE);
					jasminInstruction("castore");
					break;
				case "string":
					methodGenerator.visitInsn(AASTORE); // string is object reference
					jasminInstruction("aastore");
					break;
				default:
					throw new UnsupportedOperationException("Unsupported array element type: " + primType.getName());
			}
		}
		else {
			// Object reference
			methodGenerator.visitInsn(AASTORE);
			jasminInstruction("aastore");
		}
	}

	/**
	 * Generate array load instruction based on element type.
	 */
	private void generateArrayLoad(com.juno.types.Type elementType) {
		if (elementType instanceof PrimitiveType primType) {
			switch (primType.getName()) {
				case "bool":
					methodGenerator.visitInsn(BALOAD); // boolean uses byte array operations
					jasminInstruction("baload");
					break;
				case "byte":
				case "ubyte":
					methodGenerator.visitInsn(BALOAD);
					jasminInstruction("baload");
					break;
				case "short":
				case "ushort":
					methodGenerator.visitInsn(SALOAD);
					jasminInstruction("saload");
					break;
				case "int":
				case "uint":
					methodGenerator.visitInsn(IALOAD);
					jasminInstruction("iaload");
					break;
				case "long":
				case "ulong":
					methodGenerator.visitInsn(LALOAD);
					jasminInstruction("laload");
					break;
				case "float":
					methodGenerator.visitInsn(FALOAD);
					jasminInstruction("faload");
					break;
				case "double":
					methodGenerator.visitInsn(DALOAD);
					jasminInstruction("daload");
					break;
				case "char":
					methodGenerator.visitInsn(CALOAD);
					jasminInstruction("caload");
					break;
				case "string":
					methodGenerator.visitInsn(AALOAD); // string is object reference
					jasminInstruction("aaload");
					break;
				default:
					throw new UnsupportedOperationException("Unsupported array element type: " + primType.getName());
			}
		}
		else {
			// Object reference
			methodGenerator.visitInsn(AALOAD);
			jasminInstruction("aaload");
		}
	}
}
