package com.juno.ast;

// Import types package explicitly
// Don't import com.juno.types.* to avoid conflicts - import specific classes instead
import com.juno.types.PrimitiveType;
import org.objectweb.asm.*;
import org.objectweb.asm.commons.GeneratorAdapter;
import org.objectweb.asm.commons.Method;

import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Map;

import static org.objectweb.asm.Opcodes.*;

/**
 * JVM Code generator that translates Juno AST to JVM bytecode using the visitor pattern.
 * Each AST node type has a corresponding visit method that generates appropriate bytecode.
 */
public class CodeGenerator implements ASTVisitor<Void> {
    
    private ClassWriter classWriter;
    private GeneratorAdapter methodGenerator;  // ASM utility for method generation
    private String currentClassName;
    private Map<String, Integer> localVariables;  // Track local variable slots
    private Map<String, com.juno.types.Type> globalVariables;  // Track global variables (static fields)
    private Map<String, Expression> globalInitializers;  // Track global variable initializers
    private int nextLocalSlot;
    
    // Jasmin assembly generation
    private PrintWriter jasminWriter;
    private StringBuilder jasminOutput;
    private boolean hasJunoMainMethod = false;
    
    public void generate(Program program, String outputPath) throws IOException {
        generate(program, outputPath, true); // Default: generate Jasmin
    }
    
    public void generate(Program program, String outputPath, boolean generateJasmin) throws IOException {
        System.out.println("Starting JVM bytecode generation...");
        
        // Extract class name from output path
        String className = extractClassName(outputPath);
        this.currentClassName = className;
        this.localVariables = new HashMap<>();
        this.globalVariables = new HashMap<>();
        this.globalInitializers = new HashMap<>();
        this.nextLocalSlot = 1; // 0 is reserved for 'this' (even in static methods)
        
        // Initialize Jasmin assembly output
        this.jasminOutput = new StringBuilder();
        generateJasminHeader(className);
        
        // Create ASM ClassWriter
        classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
        
        // Generate class header
        classWriter.visit(V1_8, ACC_PUBLIC, className, null, "java/lang/Object", null);
        
        // Generate default constructor
        generateDefaultConstructor();
        
    // Visit the program AST
        program.accept(this);
        
        // Generate static initializer for global variables
        generateStaticInitializer();
        
        // Generate JVM-compatible main method if we have a Juno main
        generateJvmMainMethod();
        
        // Finalize class
        classWriter.visitEnd();
        
        // Write bytecode to file
        byte[] bytecode = classWriter.toByteArray();
        String outputFile = outputPath.endsWith(".class") ? outputPath : outputPath + ".class";
        
        try (FileOutputStream fos = new FileOutputStream(outputFile)) {
            fos.write(bytecode);
        }
        
        System.out.println("Generated bytecode: " + outputFile);
        
        // Conditionally write Jasmin assembly file
        if (generateJasmin) {
            String jasminFile = outputPath.replaceAll("\\.class$|\\.cl$", "") + ".j";
            try (PrintWriter writer = new PrintWriter(new FileWriter(jasminFile))) {
                writer.print(jasminOutput.toString());
            }
            System.out.println("Generated Jasmin assembly: " + jasminFile);
        }
    }
    
    private String extractClassName(String path) {
        // Extract class name from path like "examples/hello" -> "hello"
        String name = path;
        if (name.contains("/")) {
            name = name.substring(name.lastIndexOf("/") + 1);
        }
        if (name.contains(".")) {
            name = name.substring(0, name.indexOf("."));
        }
        return name;
    }
    
    private void generateDefaultConstructor() {
        MethodVisitor constructor = classWriter.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
        constructor.visitCode();
        constructor.visitVarInsn(ALOAD, 0);  // Load 'this'
        constructor.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
        constructor.visitInsn(RETURN);
        constructor.visitMaxs(0, 0);
        constructor.visitEnd();
    }
    
    // ===== PROGRAM AND TOP-LEVEL =====
    
    @Override
    public Void visitProgram(Program program) {
        for (Statement stmt : program.getStatements()) {
            stmt.accept(this);
        }
        return null;
    }
    
    @Override
    public Void visitModuleDeclaration(ModuleDeclaration module) {
        // For now, treat module contents as regular declarations
        for (Statement stmt : module.getStatements()) {
            stmt.accept(this);
        }
        return null;
    }
    
    @Override
    public Void visitImportStatement(ImportStatement importStmt) {
        // Imports are handled at compile time, no runtime bytecode needed
        return null;
    }
    
    @Override
    public Void visitTypeAlias(TypeAlias alias) {
        // com.juno.types.Type aliases are compile-time only, no runtime bytecode needed
        return null;
    }
    
    // ===== FUNCTION AND VARIABLE DECLARATIONS =====
    
    @Override
    public Void visitFunctionDeclaration(FunctionDeclaration funcDecl) {
        String methodName = funcDecl.getName();
        String methodDescriptor = buildMethodDescriptor(funcDecl);
        
        // Track if we have a main method
        if (methodName.equals("main") && methodDescriptor.equals("()I")) {
            hasJunoMainMethod = true;
        }
        
        // Generate Jasmin method header
        jasminComment("Function: " + methodName + methodDescriptor);
        jasminMethod(methodName + methodDescriptor, "public static");
        jasminDirective("    .limit stack 20");  // Conservative estimate
        jasminDirective("    .limit locals 20"); // Conservative estimate
        
        // Create method (public static for now)
        MethodVisitor methodVisitor = classWriter.visitMethod(
            ACC_PUBLIC | ACC_STATIC, 
            methodName, 
            methodDescriptor, 
            null, 
            null
        );
        
        // Initialize method generation context
        Method method = new Method(methodName, methodDescriptor);
        methodGenerator = new GeneratorAdapter(ACC_PUBLIC | ACC_STATIC, method, methodVisitor);
        
        // Reset local variables for this method
        localVariables.clear();
        nextLocalSlot = 0; // Static methods don't have 'this'
        
        // Assign slots to parameters
        for (FunctionDeclaration.Parameter param : funcDecl.getParameters()) {
            localVariables.put(param.name, nextLocalSlot);
            nextLocalSlot += getTypeSize(param.type);
        }
        
        methodGenerator.visitCode();
        
        // Generate function body
        if (funcDecl.getBody() != null) {
            funcDecl.getBody().accept(this);
        }
        
        // Ensure method returns (add default return if missing)
        com.juno.types.Type returnType = funcDecl.getReturnType();
        if (returnType.getName().equals("void")) {
            methodGenerator.visitInsn(RETURN);
        } else {
            // Add default return value if missing (should be caught by type checker)
            generateDefaultValue(returnType);
            generateReturn(returnType);
        }
        
        methodGenerator.visitMaxs(0, 0);
        methodGenerator.visitEnd();
        
        // End Jasmin method
        jasminEndMethod();
        
        return null;
    }
    
    @Override
    public Void visitVariableDeclaration(VariableDeclaration varDecl) {
        String varName = varDecl.getName();
        com.juno.types.Type varType = varDecl.getDeclaredType();
        
        if (methodGenerator == null) {
            // Global variable - create as static field
            String fieldDescriptor = getJVMTypeDescriptor(varType);
            
            // Track global variable and its initializer
            globalVariables.put(varName, varType);
            if (varDecl.getInitializer() != null) {
                globalInitializers.put(varName, varDecl.getInitializer());
            }
            
            // Create the static field
            FieldVisitor fieldVisitor = classWriter.visitField(
                ACC_PUBLIC | ACC_STATIC,
                varName,
                fieldDescriptor,
                null,
                null  // Will be initialized in static initializer
            );
            fieldVisitor.visitEnd();
            
            // Generate Jasmin field
            jasminField(varName, fieldDescriptor, "public static");
            
        } else {
            // Local variable - handle as before
            jasminComment("Local variable: " + varType.getName() + " " + varName);
            
            // Assign local variable slot
            localVariables.put(varName, nextLocalSlot);
            int varSlot = nextLocalSlot;
            nextLocalSlot += getTypeSize(varType);
            
            // Generate initialization code
            if (varDecl.getInitializer() != null) {
                varDecl.getInitializer().accept(this);  // Generate value on stack
                storeVariable(varType, varSlot);        // Store in local variable
            } else {
                // Initialize with default value
                jasminComment("Initialize " + varName + " with default value");
                generateDefaultValue(varType);
                storeVariable(varType, varSlot);
            }
        }
        
        return null;
    }
    
    // ===== STATEMENTS =====
    
    @Override
    public Void visitBlockStatement(BlockStatement block) {
        for (Statement stmt : block.getStatements()) {
            stmt.accept(this);
        }
        return null;
    }
    
    @Override
    public Void visitExpressionStatement(ExpressionStatement exprStmt) {
        exprStmt.getExpression().accept(this);
        // Pop the result if it's not void (expression statements discard results)
        methodGenerator.visitInsn(POP);
        return null;
    }
    
    @Override
    public Void visitReturnStatement(ReturnStatement returnStmt) {
        if (returnStmt.getValue() != null) {
            jasminComment("Return with value");
            returnStmt.getValue().accept(this);  // Generate return value
            com.juno.types.Type returnType = returnStmt.getValue().getType();
            generateReturn(returnType);
        } else {
            jasminComment("Return void");
            methodGenerator.visitInsn(RETURN);
            jasminInstruction("return");
        }
        return null;
    }
    
    @Override
    public Void visitIfStatement(IfStatement ifStmt) {
        Label elseLabel = methodGenerator.newLabel();
        Label endLabel = methodGenerator.newLabel();
        
        // Generate condition
        ifStmt.getCondition().accept(this);
        methodGenerator.visitJumpInsn(IFEQ, elseLabel);  // Jump to else if false
        
        // Generate then branch
        ifStmt.getThenStatement().accept(this);
        methodGenerator.visitJumpInsn(GOTO, endLabel);
        
        // Generate else branch
        methodGenerator.visitLabel(elseLabel);
        if (ifStmt.getElseStatement() != null) {
            ifStmt.getElseStatement().accept(this);
        }
        
        methodGenerator.visitLabel(endLabel);
        return null;
    }
    
    @Override
    public Void visitWhileStatement(WhileStatement whileStmt) {
        Label startLabel = methodGenerator.newLabel();
        Label endLabel = methodGenerator.newLabel();
        
        // Start of loop
        methodGenerator.visitLabel(startLabel);
        
        // Generate condition
        whileStmt.getCondition().accept(this);
        methodGenerator.visitJumpInsn(IFEQ, endLabel);  // Exit if false
        
        // Generate body
        whileStmt.getBody().accept(this);
        
        // Jump back to condition
        methodGenerator.visitJumpInsn(GOTO, startLabel);
        
        // End of loop
        methodGenerator.visitLabel(endLabel);
        return null;
    }
    
    @Override
    public Void visitForInStatement(ForInStatement forStmt) {
        // TODO: Implement for-in loops (requires iterator support)
        throw new UnsupportedOperationException("For-in loops not yet supported in code generation");
    }
    
    // ===== EXPRESSIONS =====
    
    @Override
    public Void visitBinaryExpression(BinaryExpression expr) {
        String operator = expr.getOperator();
        
        // Generate left operand
        expr.getLeft().accept(this);
        
        // Generate right operand
        expr.getRight().accept(this);
        
        // Generate operation
        switch (operator) {
            case "+":
                methodGenerator.visitInsn(IADD);
                jasminInstruction("iadd");
                break;
            case "-":
                methodGenerator.visitInsn(ISUB);
                jasminInstruction("isub");
                break;
            case "*":
                methodGenerator.visitInsn(IMUL);
                jasminInstruction("imul");
                break;
            case "/":
                methodGenerator.visitInsn(IDIV);
                jasminInstruction("idiv");
                break;
            case "%":
                methodGenerator.visitInsn(IREM);
                jasminInstruction("irem");
                break;
            case "<":
                generateComparison(IF_ICMPLT);
                break;
            case "<=":
                generateComparison(IF_ICMPLE);
                break;
            case ">":
                generateComparison(IF_ICMPGT);
                break;
            case ">=":
                generateComparison(IF_ICMPGE);
                break;
            case "==":
                generateComparison(IF_ICMPEQ);
                break;
            case "!=":
                generateComparison(IF_ICMPNE);
                break;
            case "&&":
                generateLogicalAnd();
                break;
            case "||":
                generateLogicalOr();
                break;
            default:
                throw new UnsupportedOperationException("Unsupported binary operator: " + operator);
        }
        
        return null;
    }
    
    @Override
    public Void visitUnaryExpression(UnaryExpression expr) {
        String operator = expr.getOperator();
        
        // Generate operand
        expr.getOperand().accept(this);
        
        switch (operator) {
            case "-":
                methodGenerator.visitInsn(INEG);
                break;
            case "+":
                // Unary plus is a no-op for integers
                break;
            case "!":
                generateLogicalNot();
                break;
            default:
                throw new UnsupportedOperationException("Unsupported unary operator: " + operator);
        }
        
        return null;
    }
    
    @Override
    public Void visitLiteralExpression(LiteralExpression expr) {
        Object value = expr.getValue();
        
        if (value instanceof Long) {
            long longValue = (Long) value;
            if (longValue >= -128 && longValue <= 127) {
                methodGenerator.visitIntInsn(BIPUSH, (int) longValue);
                jasminInstruction("bipush " + (int) longValue);
            } else if (longValue >= -32768 && longValue <= 32767) {
                methodGenerator.visitIntInsn(SIPUSH, (int) longValue);
                jasminInstruction("sipush " + (int) longValue);
            } else if (longValue >= Integer.MIN_VALUE && longValue <= Integer.MAX_VALUE) {
                methodGenerator.visitLdcInsn((int) longValue);
                jasminInstruction("ldc " + (int) longValue);
            } else {
                methodGenerator.visitLdcInsn(longValue);
                jasminInstruction("ldc2_w " + longValue + "L");
            }
        } else if (value instanceof Integer) {
            int intValue = (Integer) value;
            if (intValue >= -128 && intValue <= 127) {
                methodGenerator.visitIntInsn(BIPUSH, intValue);
                jasminInstruction("bipush " + intValue);
            } else if (intValue >= -32768 && intValue <= 32767) {
                methodGenerator.visitIntInsn(SIPUSH, intValue);
                jasminInstruction("sipush " + intValue);
            } else {
                methodGenerator.visitLdcInsn(intValue);
                jasminInstruction("ldc " + intValue);
            }
        } else if (value instanceof Float) {
            methodGenerator.visitLdcInsn((Float) value);
            jasminInstruction("ldc " + value + "f");
        } else if (value instanceof Double) {
            methodGenerator.visitLdcInsn((Double) value);
            jasminInstruction("ldc2_w " + value + "d");
        } else if (value instanceof String) {
            methodGenerator.visitLdcInsn((String) value);
            jasminInstruction("ldc \"" + value + "\"");
        } else if (value instanceof Boolean) {
            boolean boolValue = (Boolean) value;
            methodGenerator.visitIntInsn(BIPUSH, boolValue ? 1 : 0);
            jasminInstruction("bipush " + (boolValue ? "1" : "0"));
        } else if (value instanceof Character) {
            char charValue = (Character) value;
            methodGenerator.visitIntInsn(BIPUSH, (int) charValue);
            jasminInstruction("bipush " + (int) charValue + " ; '" + charValue + "'");
        } else {
            throw new UnsupportedOperationException("Unsupported literal type: " + value.getClass());
        }
        
        return null;
    }
    
    @Override
    public Void visitIdentifierExpression(IdentifierExpression expr) {
        String varName = expr.getName();
        Integer slot = localVariables.get(varName);
        
        if (slot != null) {
            // Local variable - load from local slot
            com.juno.types.Type varType = expr.getType();
            loadVariable(varType, slot);
        } else if (globalVariables.containsKey(varName)) {
            // Global variable - load from static field
            com.juno.types.Type varType = globalVariables.get(varName);
            String fieldDescriptor = getJVMTypeDescriptor(varType);
            methodGenerator.visitFieldInsn(GETSTATIC, currentClassName, varName, fieldDescriptor);
        } else {
            throw new RuntimeException("Undefined variable: " + varName);
        }
        
        return null;
    }
    
    @Override
    public Void visitAssignmentExpression(AssignmentExpression expr) {
        if (!(expr.getTarget() instanceof IdentifierExpression)) {
            throw new UnsupportedOperationException("Only simple variable assignment supported");
        }
        
        IdentifierExpression target = (IdentifierExpression) expr.getTarget();
        String varName = target.getName();
        Integer slot = localVariables.get(varName);
        
        if (slot == null) {
            throw new RuntimeException("Undefined variable: " + varName);
        }
        
        // Generate value
        expr.getValue().accept(this);
        
        // Duplicate value on stack (assignment returns the assigned value)
        methodGenerator.visitInsn(DUP);
        
        // Store in variable
        com.juno.types.Type varType = expr.getType();
        storeVariable(varType, slot);
        
        return null;
    }
    
    @Override
    public Void visitCallExpression(CallExpression expr) {
        Expression function = expr.getFunction();
        String functionName;
        
        // Extract function name (for now, only support simple identifier functions)
        if (function instanceof IdentifierExpression) {
            functionName = ((IdentifierExpression) function).getName();
        } else {
            throw new UnsupportedOperationException("Only simple function calls supported: " + function.getClass());
        }
        
        // Generate arguments
        for (Expression arg : expr.getArguments()) {
            arg.accept(this);
        }
        
        // For now, assume all functions are static methods in the same class
        // TODO: Handle function signatures properly
        String methodDescriptor = buildFunctionCallDescriptor(expr);
        methodGenerator.visitMethodInsn(INVOKESTATIC, currentClassName, functionName, methodDescriptor, false);
        jasminInstruction("invokestatic " + currentClassName + "/" + functionName + methodDescriptor);
        
        return null;
    }
    
    @Override
    public Void visitQualifiedIdentifier(QualifiedIdentifier expr) {
        // TODO: Implement module-qualified identifiers
        throw new UnsupportedOperationException("Qualified identifiers not yet supported in code generation");
    }
    
    @Override
    public Void visitCastExpression(CastExpression expr) {
        // Generate the expression to be cast
        expr.getExpression().accept(this);
        
        // TODO: Implement proper type casting
        // For now, assume compatible types (type checker should ensure this)
        
        return null;
    }
    
    // ===== UTILITY METHODS =====
    
    private String buildMethodDescriptor(FunctionDeclaration funcDecl) {
        StringBuilder descriptor = new StringBuilder("(");
        
        // Parameter types
        for (FunctionDeclaration.Parameter param : funcDecl.getParameters()) {
            descriptor.append(getJVMTypeDescriptor(param.type));
        }
        
        descriptor.append(")");
        
        // Return type
        descriptor.append(getJVMTypeDescriptor(funcDecl.getReturnType()));
        
        return descriptor.toString();
    }
    
    private String buildFunctionCallDescriptor(CallExpression callExpr) {
        StringBuilder descriptor = new StringBuilder("(");
        
        // Parameter types (inferred from argument types)
        // TODO: This is a hack - we should look up the actual method signature
        for (Expression arg : callExpr.getArguments()) {
            com.juno.types.Type argType = arg.getType();
            
            // Force integer literals to use int type (hack for now)
            if (argType != null && argType.getName().equals("long") && 
                arg instanceof LiteralExpression) {
                descriptor.append("I"); // Use int descriptor instead of long
            } else {
                descriptor.append(getJVMTypeDescriptor(argType));
            }
        }
        
        descriptor.append(")");
        
        // Return type (from the call expression's type)
        com.juno.types.Type returnType = callExpr.getType();
        descriptor.append(getJVMTypeDescriptor(returnType));
        
        return descriptor.toString();
    }
    
    private String getJVMTypeDescriptor(com.juno.types.Type type) {
        if (type instanceof PrimitiveType) {
            switch (type.getName()) {
                case "void": return "V";
                case "bool": return "Z";
                case "byte": case "ubyte": return "B";
                case "short": case "ushort": return "S";
                case "int": case "uint": return "I";
                case "long": case "ulong": return "J";
                case "float": return "F";
                case "double": return "D";
                case "char": return "C";
                case "string": return "Ljava/lang/String;";
                default: throw new UnsupportedOperationException("Unsupported primitive type: " + type.getName());
            }
        } else {
            // For now, treat complex types as Object
            return "Ljava/lang/Object;";
        }
    }
    
    private int getTypeSize(com.juno.types.Type type) {
        if (type instanceof PrimitiveType) {
            switch (type.getName()) {
                case "long": case "ulong": case "double":
                    return 2;  // 64-bit types take 2 slots
                default:
                    return 1;  // All other types take 1 slot
            }
        }
        return 1;
    }
    
    private void loadVariable(com.juno.types.Type type, int slot) {
        if (type == null) {
            methodGenerator.visitVarInsn(ILOAD, slot);  // Default to int
            jasminInstruction("iload " + slot);
            return;
        }
        
        if (type instanceof PrimitiveType) {
            switch (type.getName()) {
                case "bool": case "byte": case "ubyte": 
                case "short": case "ushort": case "int": case "uint": case "char":
                    methodGenerator.visitVarInsn(ILOAD, slot);
                    jasminInstruction("iload " + slot);
                    break;
                case "long": case "ulong":
                    methodGenerator.visitVarInsn(LLOAD, slot);
                    jasminInstruction("lload " + slot);
                    break;
                case "float":
                    methodGenerator.visitVarInsn(FLOAD, slot);
                    jasminInstruction("fload " + slot);
                    break;
                case "double":
                    methodGenerator.visitVarInsn(DLOAD, slot);
                    jasminInstruction("dload " + slot);
                    break;
                case "string":
                    methodGenerator.visitVarInsn(ALOAD, slot);
                    jasminInstruction("aload " + slot);
                    break;
                default:
                    methodGenerator.visitVarInsn(ILOAD, slot);
                    jasminInstruction("iload " + slot);
            }
        } else {
            methodGenerator.visitVarInsn(ALOAD, slot);  // Object reference
            jasminInstruction("aload " + slot);
        }
    }
    
    private void storeVariable(com.juno.types.Type type, int slot) {
        if (type == null) {
            methodGenerator.visitVarInsn(ISTORE, slot);  // Default to int
            jasminInstruction("istore " + slot);
            return;
        }
        
        if (type instanceof PrimitiveType) {
            switch (type.getName()) {
                case "bool": case "byte": case "ubyte":
                case "short": case "ushort": case "int": case "uint": case "char":
                    methodGenerator.visitVarInsn(ISTORE, slot);
                    jasminInstruction("istore " + slot);
                    break;
                case "long": case "ulong":
                    methodGenerator.visitVarInsn(LSTORE, slot);
                    jasminInstruction("lstore " + slot);
                    break;
                case "float":
                    methodGenerator.visitVarInsn(FSTORE, slot);
                    jasminInstruction("fstore " + slot);
                    break;
                case "double":
                    methodGenerator.visitVarInsn(DSTORE, slot);
                    jasminInstruction("dstore " + slot);
                    break;
                case "string":
                    methodGenerator.visitVarInsn(ASTORE, slot);
                    jasminInstruction("astore " + slot);
                    break;
                default:
                    methodGenerator.visitVarInsn(ISTORE, slot);
                    jasminInstruction("istore " + slot);
            }
        } else {
            methodGenerator.visitVarInsn(ASTORE, slot);  // Object reference
            jasminInstruction("astore " + slot);
        }
    }
    
    private void generateDefaultValue(com.juno.types.Type type) {
        if (type instanceof PrimitiveType) {
            switch (type.getName()) {
                case "bool": case "byte": case "ubyte":
                case "short": case "ushort": case "int": case "uint": case "char":
                    methodGenerator.visitInsn(ICONST_0);
                    break;
                case "long": case "ulong":
                    methodGenerator.visitInsn(LCONST_0);
                    break;
                case "float":
                    methodGenerator.visitInsn(FCONST_0);
                    break;
                case "double":
                    methodGenerator.visitInsn(DCONST_0);
                    break;
                case "string":
                    methodGenerator.visitInsn(ACONST_NULL);
                    break;
                default:
                    methodGenerator.visitInsn(ICONST_0);
            }
        } else {
            methodGenerator.visitInsn(ACONST_NULL);
        }
    }
    
    private void generateReturn(com.juno.types.Type returnType) {
        if (returnType instanceof PrimitiveType) {
            switch (returnType.getName()) {
                case "void":
                    methodGenerator.visitInsn(RETURN);
                    jasminInstruction("return");
                    break;
                case "bool": case "byte": case "ubyte":
                case "short": case "ushort": case "int": case "uint": case "char":
                    methodGenerator.visitInsn(IRETURN);
                    jasminInstruction("ireturn");
                    break;
                case "long": case "ulong":
                    methodGenerator.visitInsn(LRETURN);
                    jasminInstruction("lreturn");
                    break;
                case "float":
                    methodGenerator.visitInsn(FRETURN);
                    jasminInstruction("freturn");
                    break;
                case "double":
                    methodGenerator.visitInsn(DRETURN);
                    jasminInstruction("dreturn");
                    break;
                case "string":
                    methodGenerator.visitInsn(ARETURN);
                    jasminInstruction("areturn");
                    break;
                default:
                    methodGenerator.visitInsn(IRETURN);
                    jasminInstruction("ireturn");
            }
        } else {
            methodGenerator.visitInsn(ARETURN);
            jasminInstruction("areturn");
        }
    }
    
    private void generateComparison(int compareOpcode) {
        Label trueLabel = methodGenerator.newLabel();
        Label endLabel = methodGenerator.newLabel();
        
        // Compare and jump to true label if condition holds
        methodGenerator.visitJumpInsn(compareOpcode, trueLabel);
        
        // False case: push 0
        methodGenerator.visitInsn(ICONST_0);
        methodGenerator.visitJumpInsn(GOTO, endLabel);
        
        // True case: push 1
        methodGenerator.visitLabel(trueLabel);
        methodGenerator.visitInsn(ICONST_1);
        
        methodGenerator.visitLabel(endLabel);
    }
    
    private void generateLogicalNot() {
        Label trueLabel = methodGenerator.newLabel();
        Label endLabel = methodGenerator.newLabel();
        
        // If value is 0 (false), jump to true label
        methodGenerator.visitJumpInsn(IFEQ, trueLabel);
        
        // Value was non-zero (true), so result is false (0)
        methodGenerator.visitInsn(ICONST_0);
        methodGenerator.visitJumpInsn(GOTO, endLabel);
        
        // Value was zero (false), so result is true (1)
        methodGenerator.visitLabel(trueLabel);
        methodGenerator.visitInsn(ICONST_1);
        
        methodGenerator.visitLabel(endLabel);
    }
    
    private void generateLogicalAnd() {
        Label falseLabel = methodGenerator.newLabel();
        Label endLabel = methodGenerator.newLabel();
        
        // Left operand is already on stack
        // Duplicate it for the test
        methodGenerator.visitInsn(DUP);
        methodGenerator.visitJumpInsn(IFEQ, falseLabel);  // If left is false, short-circuit
        
        // Left was true, pop it and use right operand result
        methodGenerator.visitInsn(POP);
        // Right operand is already on stack
        methodGenerator.visitJumpInsn(GOTO, endLabel);
        
        // Left was false, pop right operand and push false
        methodGenerator.visitLabel(falseLabel);
        methodGenerator.visitInsn(POP);  // Pop right operand
        methodGenerator.visitInsn(ICONST_0);
        
        methodGenerator.visitLabel(endLabel);
    }
    
    private void generateLogicalOr() {
        Label trueLabel = methodGenerator.newLabel();
        Label endLabel = methodGenerator.newLabel();
        
        // Left operand is already on stack
        // Duplicate it for the test
        methodGenerator.visitInsn(DUP);
        methodGenerator.visitJumpInsn(IFNE, trueLabel);  // If left is true, short-circuit
        
        // Left was false, pop it and use right operand result
        methodGenerator.visitInsn(POP);
        // Right operand is already on stack
        methodGenerator.visitJumpInsn(GOTO, endLabel);
        
        // Left was true, pop right operand and push true
        methodGenerator.visitLabel(trueLabel);
        methodGenerator.visitInsn(POP);  // Pop right operand
        methodGenerator.visitInsn(ICONST_1);
        
        methodGenerator.visitLabel(endLabel);
    }
    
    // ===== JASMIN ASSEMBLY GENERATION =====
    
    private void generateJasminHeader(String className) {
        jasminOutput.append(".class public ").append(className).append("\n");
        jasminOutput.append(".super java/lang/Object\n\n");
        
        // Generate default constructor
        jasminOutput.append(".method public <init>()V\n");
        jasminOutput.append("    .limit stack 1\n");
        jasminOutput.append("    .limit locals 1\n");
        jasminOutput.append("    aload_0\n");
        jasminOutput.append("    invokespecial java/lang/Object/<init>()V\n");
        jasminOutput.append("    return\n");
        jasminOutput.append(".end method\n\n");
    }
    
    private void jasminComment(String comment) {
        jasminOutput.append("; ").append(comment).append("\n");
    }
    
    private void jasminInstruction(String instruction) {
        jasminOutput.append("    ").append(instruction).append("\n");
    }
    
    private void jasminLabel(String label) {
        jasminOutput.append(label).append(":\n");
    }
    
    private void jasminDirective(String directive) {
        jasminOutput.append(directive).append("\n");
    }
    
    private void jasminMethod(String signature, String access) {
        jasminOutput.append(".method ").append(access).append(" ").append(signature).append("\n");
    }
    
    private void jasminEndMethod() {
        jasminOutput.append(".end method\n\n");
    }
    
    private void jasminField(String name, String descriptor, String access) {
        jasminOutput.append(".field ").append(access).append(" ")
                   .append(name).append(" ").append(descriptor).append("\n");
    }
    
    private void generateStaticInitializer() {
        if (globalInitializers.isEmpty()) {
            return; // No initialization needed
        }
        
        // Create static initializer method <clinit>
        MethodVisitor clinit = classWriter.visitMethod(ACC_STATIC, "<clinit>", "()V", null, null);
        methodGenerator = new GeneratorAdapter(ACC_STATIC, new Method("<clinit>", "()V"), clinit);
        
        // Generate Jasmin static initializer
        jasminComment("Static initializer for global variables");
        jasminMethod("<clinit>()V", "static");
        jasminDirective("    .limit stack 10");
        jasminDirective("    .limit locals 1");
        
        methodGenerator.visitCode();
        
        // Initialize each global variable with its initializer
        for (String varName : globalInitializers.keySet()) {
            Expression initializer = globalInitializers.get(varName);
            com.juno.types.Type varType = globalVariables.get(varName);
            
            jasminComment("Initialize " + varName);
            
            // Generate initialization value
            initializer.accept(this);
            
            // Add type conversion if needed
            if (varType instanceof PrimitiveType && varType.getName().equals("float") &&
                initializer instanceof LiteralExpression) {
                Object value = ((LiteralExpression) initializer).getValue();
                if (value instanceof Double) {
                    // Convert double to float on the stack
                    methodGenerator.visitInsn(D2F);
                    jasminInstruction("d2f");
                }
            }
            
            // Store in static field
            String fieldDescriptor = getJVMTypeDescriptor(varType);
            methodGenerator.visitFieldInsn(PUTSTATIC, currentClassName, varName, fieldDescriptor);
        }
        
        // Return from static initializer
        methodGenerator.visitInsn(RETURN);
        methodGenerator.visitMaxs(0, 0);
        methodGenerator.visitEnd();
        
        // End Jasmin static initializer
        jasminInstruction("return");
        jasminEndMethod();
        
        // Clear method generator
        methodGenerator = null;
    }
    
    private void generateJvmMainMethod() {
        if (!hasJunoMainMethod) {
            return; // No Juno main method to wrap
        }
        
        // Create JVM-compatible main method: public static void main(String[] args)
        MethodVisitor mainMethod = classWriter.visitMethod(
            ACC_PUBLIC | ACC_STATIC, 
            "main", 
            "([Ljava/lang/String;)V", 
            null, 
            null
        );
        
        methodGenerator = new GeneratorAdapter(ACC_PUBLIC | ACC_STATIC, 
            new Method("main", "([Ljava/lang/String;)V"), mainMethod);
        
        // Generate Jasmin JVM main method
        jasminComment("JVM-compatible main method wrapper");
        jasminMethod("main([Ljava/lang/String;)V", "public static");
        jasminDirective("    .limit stack 10");
        jasminDirective("    .limit locals 1");
        
        methodGenerator.visitCode();
        
        // Call our Juno main() method and get the result
        methodGenerator.visitMethodInsn(INVOKESTATIC, currentClassName, "main", "()I", false);
        jasminInstruction("invokestatic " + currentClassName + "/main()I");
        
        // Print the result to stdout (standard JVM behavior)
        methodGenerator.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
        jasminInstruction("getstatic java/lang/System/out Ljava/io/PrintStream;");
        
        methodGenerator.visitInsn(SWAP);  // Put result before PrintStream
        jasminInstruction("swap");
        
        methodGenerator.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(I)V", false);
        jasminInstruction("invokevirtual java/io/PrintStream/println(I)V");
        
        // Return void (standard JVM main behavior)
        methodGenerator.visitInsn(RETURN);
        jasminInstruction("return");
        
        methodGenerator.visitMaxs(0, 0);
        methodGenerator.visitEnd();
        
        // End Jasmin JVM main method
        jasminEndMethod();
        
        // Clear method generator
        methodGenerator = null;
    }
}
