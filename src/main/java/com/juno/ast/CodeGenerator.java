package com.juno.ast;

// Import types package explicitly
// Don't import com.juno.types.* to avoid conflicts - import specific classes instead
import com.juno.types.PrimitiveType;
import org.objectweb.asm.*;
import org.objectweb.asm.commons.GeneratorAdapter;
import org.objectweb.asm.commons.Method;

import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Map;

import static org.objectweb.asm.Opcodes.*;

/**
 * JVM Code generator that translates Juno AST to JVM bytecode using the visitor pattern.
 * Each AST node type has a corresponding visit method that generates appropriate bytecode.
 */
public class CodeGenerator implements ASTVisitor<Void> {
    
    private ClassWriter classWriter;
    private GeneratorAdapter methodGenerator;  // ASM utility for method generation
    private String currentClassName;
    private Map<String, Integer> localVariables;  // Track local variable slots
    private Map<String, com.juno.types.Type> globalVariables;  // Track global variables (static fields)
    private Map<String, Expression> globalInitializers;  // Track global variable initializers
    private com.juno.types.Type currentFunctionReturnType;  // Track current function's return type
    private int nextLocalSlot;
    private int labelCounter = 0;  // Counter for unique labels
    
    // Jasmin assembly generation
    private PrintWriter jasminWriter;
    private StringBuilder jasminOutput;
    private boolean hasJunoMainMethod = false;
    private com.juno.types.Type junoMainReturnType = null;
    
    public void generate(Program program, String outputPath) throws IOException {
        generate(program, outputPath, true); // Default: generate Jasmin
    }
    
    public void generate(Program program, String outputPath, boolean generateJasmin) throws IOException {
        System.out.println("Starting JVM bytecode generation...");
        
        // Extract class name from output path
        String className = extractClassName(outputPath);
        this.currentClassName = className;
        this.localVariables = new HashMap<>();
        this.globalVariables = new HashMap<>();
        this.globalInitializers = new HashMap<>();
        this.nextLocalSlot = 1; // 0 is reserved for 'this' (even in static methods)
        
        // Initialize Jasmin assembly output
        this.jasminOutput = new StringBuilder();
        generateJasminHeader(className);
        
        // Create ASM ClassWriter
        classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
        
        // Generate class header
        classWriter.visit(V1_8, ACC_PUBLIC, className, null, "java/lang/Object", null);
        
        // Generate default constructor
        generateDefaultConstructor();
        
    // Visit the program AST
        program.accept(this);
        
        // Generate static initializer for global variables
        generateStaticInitializer();
        
        // Generate JVM-compatible main method if we have a Juno main
        generateJvmMainMethod();
        
        // Finalize class
        classWriter.visitEnd();
        
        // Write bytecode to file
        byte[] bytecode = classWriter.toByteArray();
        String outputFile = outputPath.endsWith(".class") ? outputPath : outputPath + ".class";
        
        try (FileOutputStream fos = new FileOutputStream(outputFile)) {
            fos.write(bytecode);
        }
        
        System.out.println("Generated bytecode: " + outputFile);
        System.out.println("Run with: java " + className);
        
        // Conditionally write Jasmin assembly file
        if (generateJasmin) {
            String jasminFile = outputPath.replaceAll("\\.class$|\\.cl$", "") + ".j";
            try (PrintWriter writer = new PrintWriter(new FileWriter(jasminFile))) {
                writer.print(jasminOutput.toString());
            }
            System.out.println("Generated Jasmin assembly: " + jasminFile);
        }
    }
    
    private String extractClassName(String path) {
        // Extract class name from path like "examples/hello" -> "hello"
        String name = path;
        if (name.contains("/")) {
            name = name.substring(name.lastIndexOf("/") + 1);
        }
        if (name.contains(".")) {
            name = name.substring(0, name.indexOf("."));
        }
        return name;
    }
    
    private void generateDefaultConstructor() {
        MethodVisitor constructor = classWriter.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
        constructor.visitCode();
        constructor.visitVarInsn(ALOAD, 0);  // Load 'this'
        constructor.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
        constructor.visitInsn(RETURN);
        constructor.visitMaxs(0, 0);
        constructor.visitEnd();
    }
    
    // ===== PROGRAM AND TOP-LEVEL =====
    
    @Override
    public Void visitProgram(Program program) {
        for (Statement stmt : program.getStatements()) {
            stmt.accept(this);
        }
        return null;
    }
    
    @Override
    public Void visitModuleDeclaration(ModuleDeclaration module) {
        // For now, treat module contents as regular declarations
        for (Statement stmt : module.getStatements()) {
            stmt.accept(this);
        }
        return null;
    }
    
    @Override
    public Void visitImportStatement(ImportStatement importStmt) {
        // Imports are handled at compile time, no runtime bytecode needed
        return null;
    }
    
    @Override
    public Void visitTypeAlias(TypeAlias alias) {
        // com.juno.types.Type aliases are compile-time only, no runtime bytecode needed
        return null;
    }
    
    // ===== FUNCTION AND VARIABLE DECLARATIONS =====
    
    @Override
    public Void visitFunctionDeclaration(FunctionDeclaration funcDecl) {
        String methodName = funcDecl.getName();
        String methodDescriptor = buildMethodDescriptor(funcDecl);
        
        // Track if we have a main method (int or long return)
        if (methodName.equals("main") && 
            (methodDescriptor.equals("()I") || methodDescriptor.equals("()J"))) {
            hasJunoMainMethod = true;
            junoMainReturnType = funcDecl.getReturnType();
        }
        
        // Track current function's return type
        currentFunctionReturnType = funcDecl.getReturnType();
        
        // Generate Jasmin method header
        jasminComment("Function: " + methodName + methodDescriptor);
        jasminMethod(methodName + methodDescriptor, "public static");
        jasminDirective("    .limit stack 20");  // Conservative estimate
        jasminDirective("    .limit locals 20"); // Conservative estimate
        
        // Create method (public static for now)
        MethodVisitor methodVisitor = classWriter.visitMethod(
            ACC_PUBLIC | ACC_STATIC, 
            methodName, 
            methodDescriptor, 
            null, 
            null
        );
        
        // Initialize method generation context
        Method method = new Method(methodName, methodDescriptor);
        methodGenerator = new GeneratorAdapter(ACC_PUBLIC | ACC_STATIC, method, methodVisitor);
        
        // Reset local variables for this method
        localVariables.clear();
        nextLocalSlot = 0; // Static methods don't have 'this'
        
        // Assign slots to parameters
        for (FunctionDeclaration.Parameter param : funcDecl.getParameters()) {
            localVariables.put(param.name, nextLocalSlot);
            nextLocalSlot += getTypeSize(param.type);
        }
        
        methodGenerator.visitCode();
        
        // Generate function body
        if (funcDecl.getBody() != null) {
            funcDecl.getBody().accept(this);
        }
        
        // For void methods, add return if missing
        com.juno.types.Type returnType = funcDecl.getReturnType();
        if (returnType.getName().equals("void")) {
            methodGenerator.visitInsn(RETURN);
            jasminInstruction("return");
        }
        // Non-void methods should have explicit return statements (verified by type checker)
        
        methodGenerator.visitMaxs(0, 0);
        methodGenerator.visitEnd();
        
        // End Jasmin method
        jasminEndMethod();
        
        return null;
    }
    
    @Override
    public Void visitVariableDeclaration(VariableDeclaration varDecl) {
        String varName = varDecl.getName();
        com.juno.types.Type varType = varDecl.getDeclaredType();
        
        if (methodGenerator == null) {
            // Global variable - create as static field
            String fieldDescriptor = getJVMTypeDescriptor(varType);
            
            // Track global variable and its initializer
            globalVariables.put(varName, varType);
            if (varDecl.getInitializer() != null) {
                globalInitializers.put(varName, varDecl.getInitializer());
            }
            
            // Create the static field
            FieldVisitor fieldVisitor = classWriter.visitField(
                ACC_PUBLIC | ACC_STATIC,
                varName,
                fieldDescriptor,
                null,
                null  // Will be initialized in static initializer
            );
            fieldVisitor.visitEnd();
            
            // Generate Jasmin field
            jasminField(varName, fieldDescriptor, "public static");
            
        } else {
            // Local variable - handle as before
            jasminComment("Local variable: " + varType.getName() + " " + varName);
            
            // Assign local variable slot
            localVariables.put(varName, nextLocalSlot);
            int varSlot = nextLocalSlot;
            nextLocalSlot += getTypeSize(varType);
            
            // Generate initialization code
            if (varDecl.getInitializer() != null) {
                varDecl.getInitializer().accept(this);  // Generate value on stack
                
                // Add type conversion if needed between initializer and variable type
                com.juno.types.Type initializerType = varDecl.getInitializer().getType();
                if (initializerType != null && !initializerType.equals(varType)) {
                    jasminComment("Convert " + initializerType.getName() + " to " + varType.getName());
                    generateTypeConversion(initializerType, varType);
                }
                
                storeVariable(varType, varSlot);        // Store in local variable
            } else {
                // Initialize with default value
                jasminComment("Initialize " + varName + " with default value");
                generateDefaultValue(varType);
                storeVariable(varType, varSlot);
            }
        }
        
        return null;
    }
    
    // ===== STATEMENTS =====
    
    @Override
    public Void visitBlockStatement(BlockStatement block) {
        for (Statement stmt : block.getStatements()) {
            stmt.accept(this);
        }
        return null;
    }
    
    @Override
    public Void visitExpressionStatement(ExpressionStatement exprStmt) {
        exprStmt.getExpression().accept(this);
        // Pop the result if it's not void (expression statements discard results)
        methodGenerator.visitInsn(POP);
        return null;
    }
    
    @Override
    public Void visitReturnStatement(ReturnStatement returnStmt) {
        if (returnStmt.getValue() != null) {
            jasminComment("Return with value");
            returnStmt.getValue().accept(this);  // Generate return value
            
            // CRITICAL: Handle type conversion for long returns
            // Always convert to long when function returns long, since most expressions
            // produce int values on the JVM stack regardless of AST-level type inference
            if (isLongType(currentFunctionReturnType)) {
                // Check if the return expression produces a long value or needs conversion
                if (producesLongValue(returnStmt.getValue()) || 
                    isLongArithmeticExpression(returnStmt.getValue())) {
                    jasminComment("Return value already long - no conversion needed");
                } else {
                    jasminComment("Converting int to long for ulong return");
                    methodGenerator.visitInsn(I2L);
                    jasminInstruction("i2l");
                }
            }
            
            // Use the function's declared return type
            generateReturn(currentFunctionReturnType);
        } else {
            jasminComment("Return void");
            methodGenerator.visitInsn(RETURN);
            jasminInstruction("return");
        }
        return null;
    }
    
    @Override
    public Void visitIfStatement(IfStatement ifStmt) {
        Label elseLabel = methodGenerator.newLabel();
        Label endLabel = methodGenerator.newLabel();
        int elseLabelId = ++labelCounter;
        int endLabelId = ++labelCounter;
        
        // Generate condition
        ifStmt.getCondition().accept(this);
        methodGenerator.visitJumpInsn(IFEQ, elseLabel);  // Jump to else if false
        jasminInstruction("ifeq else_" + elseLabelId);
        
        // Generate then branch
        ifStmt.getThenStatement().accept(this);
        methodGenerator.visitJumpInsn(GOTO, endLabel);
        jasminInstruction("goto end_" + endLabelId);
        
        // Generate else branch
        methodGenerator.visitLabel(elseLabel);
        jasminLabel("else_" + elseLabelId);
        if (ifStmt.getElseStatement() != null) {
            ifStmt.getElseStatement().accept(this);
        }
        
        methodGenerator.visitLabel(endLabel);
        jasminLabel("end_" + endLabelId);
        return null;
    }
    
    @Override
    public Void visitWhileStatement(WhileStatement whileStmt) {
        Label startLabel = methodGenerator.newLabel();
        Label endLabel = methodGenerator.newLabel();
        
        // Start of loop
        methodGenerator.visitLabel(startLabel);
        
        // Generate condition
        whileStmt.getCondition().accept(this);
        methodGenerator.visitJumpInsn(IFEQ, endLabel);  // Exit if false
        
        // Generate body
        whileStmt.getBody().accept(this);
        
        // Jump back to condition
        methodGenerator.visitJumpInsn(GOTO, startLabel);
        
        // End of loop
        methodGenerator.visitLabel(endLabel);
        return null;
    }
    
    @Override
    public Void visitForInStatement(ForInStatement forStmt) {
        // TODO: Implement for-in loops (requires iterator support)
        throw new UnsupportedOperationException("For-in loops not yet supported in code generation");
    }
    
    // ===== EXPRESSIONS =====
    
    @Override
    public Void visitBinaryExpression(BinaryExpression expr) {
        String operator = expr.getOperator();
        
        // Generate left operand
        expr.getLeft().accept(this);
        boolean leftProducesLong = producesLongValue(expr.getLeft());
        
        // Generate right operand
        expr.getRight().accept(this);
        boolean rightProducesLong = producesLongValue(expr.getRight());
        
        // Convert operands to long if needed for mixed arithmetic
        boolean isLongArithmetic = leftProducesLong || rightProducesLong;
        if (isLongArithmetic) {
            if (rightProducesLong && !leftProducesLong) {
                // Right is long, left is int - need to promote left
                // Stack: [int, long_low, long_high] -> [long_low, long_high, long_low, long_high]
                methodGenerator.visitInsn(DUP2_X1);  // Duplicate long below int
                methodGenerator.visitInsn(POP2);     // Remove duplicated long
                methodGenerator.visitInsn(I2L);      // Convert int to long
                methodGenerator.visitInsn(DUP2_X2);  // Move converted long below original long
                methodGenerator.visitInsn(POP2);     // Remove duplicated converted long
                jasminInstruction("dup2_x1");
                jasminInstruction("pop2");
                jasminInstruction("i2l");
                jasminInstruction("dup2_x2");
                jasminInstruction("pop2");
            } else if (leftProducesLong && !rightProducesLong) {
                // Left is long, right is int - need to promote right
                // Stack: [long_low, long_high, int] -> [long_low, long_high, long_low, long_high]
                methodGenerator.visitInsn(I2L);      // Convert int to long
                jasminInstruction("i2l");
            }
        }
        
        switch (operator) {
            case "+":
                if (isLongArithmetic) {
                    methodGenerator.visitInsn(LADD);
                    jasminInstruction("ladd");
                } else {
                    methodGenerator.visitInsn(IADD);
                    jasminInstruction("iadd");
                }
                break;
            case "-":
                if (isLongArithmetic) {
                    methodGenerator.visitInsn(LSUB);
                    jasminInstruction("lsub");
                } else {
                    methodGenerator.visitInsn(ISUB);
                    jasminInstruction("isub");
                }
                break;
            case "*":
                if (isLongArithmetic) {
                    methodGenerator.visitInsn(LMUL);
                    jasminInstruction("lmul");
                } else {
                    methodGenerator.visitInsn(IMUL);
                    jasminInstruction("imul");
                }
                break;
            case "/":
                if (isLongArithmetic) {
                    methodGenerator.visitInsn(LDIV);
                    jasminInstruction("ldiv");
                } else {
                    methodGenerator.visitInsn(IDIV);
                    jasminInstruction("idiv");
                }
                break;
            case "%":
                if (isLongArithmetic) {
                    methodGenerator.visitInsn(LREM);
                    jasminInstruction("lrem");
                } else {
                    methodGenerator.visitInsn(IREM);
                    jasminInstruction("irem");
                }
                break;
            case "<":
                generateComparison(IF_ICMPLT);
                break;
            case "<=":
                generateComparison(IF_ICMPLE);
                jasminComment("Comparison: <=");
                break;
            case ">":
                generateComparison(IF_ICMPGT);
                jasminComment("Comparison: >");
                break;
            case ">=":
                generateComparison(IF_ICMPGE);
                jasminComment("Comparison: >=");
                break;
            case "==":
                generateComparison(IF_ICMPEQ);
                break;
            case "!=":
                generateComparison(IF_ICMPNE);
                break;
            case "&&":
                generateLogicalAnd();
                break;
            case "||":
                generateLogicalOr();
                break;
            default:
                throw new UnsupportedOperationException("Unsupported binary operator: " + operator);
        }
        
        return null;
    }
    
    @Override
    public Void visitUnaryExpression(UnaryExpression expr) {
        String operator = expr.getOperator();
        
        // Generate operand
        expr.getOperand().accept(this);
        
        switch (operator) {
            case "-":
                methodGenerator.visitInsn(INEG);
                break;
            case "+":
                // Unary plus is a no-op for integers
                break;
            case "!":
                generateLogicalNot();
                break;
            default:
                throw new UnsupportedOperationException("Unsupported unary operator: " + operator);
        }
        
        return null;
    }
    
    @Override
    public Void visitLiteralExpression(LiteralExpression expr) {
        Object value = expr.getValue();
        com.juno.types.Type astType = expr.getType();
        
        // Check if AST type indicates this should be a long value
        boolean shouldBeLong = (astType != null && isLongType(astType));
        
        if (value instanceof Long) {
            long longValue = (Long) value;
            // Always generate proper long instructions for long literals
            if (longValue >= Integer.MIN_VALUE && longValue <= Integer.MAX_VALUE) {
                // Small long values: push as int and convert to long
                methodGenerator.visitLdcInsn((int) longValue);
                methodGenerator.visitInsn(I2L);
                jasminInstruction("ldc " + (int) longValue);
                jasminInstruction("i2l ; convert to long");
            } else {
                // Large long values: use ldc2_w
                methodGenerator.visitLdcInsn(longValue);
                jasminInstruction("ldc2_w " + longValue + "L");
            }
        } else if (value instanceof Integer) {
            int intValue = (Integer) value;
            
            if (shouldBeLong) {
                // Integer value but AST type is long - generate as int then convert
                if (intValue >= -128 && intValue <= 127) {
                    methodGenerator.visitIntInsn(BIPUSH, intValue);
                    jasminInstruction("bipush " + intValue);
                } else if (intValue >= -32768 && intValue <= 32767) {
                    methodGenerator.visitIntInsn(SIPUSH, intValue);
                    jasminInstruction("sipush " + intValue);
                } else {
                    methodGenerator.visitLdcInsn(intValue);
                    jasminInstruction("ldc " + intValue);
                }
                // Convert int to long since AST type is long
                methodGenerator.visitInsn(I2L);
                jasminInstruction("i2l ; convert to long for AST type");
            } else {
                // Regular integer literal
                if (intValue >= -128 && intValue <= 127) {
                    methodGenerator.visitIntInsn(BIPUSH, intValue);
                    jasminInstruction("bipush " + intValue);
                } else if (intValue >= -32768 && intValue <= 32767) {
                    methodGenerator.visitIntInsn(SIPUSH, intValue);
                    jasminInstruction("sipush " + intValue);
                } else {
                    methodGenerator.visitLdcInsn(intValue);
                    jasminInstruction("ldc " + intValue);
                }
            }
        } else if (value instanceof Float) {
            methodGenerator.visitLdcInsn((Float) value);
            jasminInstruction("ldc " + value + "f");
        } else if (value instanceof Double) {
            methodGenerator.visitLdcInsn((Double) value);
            jasminInstruction("ldc2_w " + value + "d");
        } else if (value instanceof String) {
            methodGenerator.visitLdcInsn((String) value);
            jasminInstruction("ldc \"" + value + "\"");
        } else if (value instanceof Boolean) {
            boolean boolValue = (Boolean) value;
            methodGenerator.visitIntInsn(BIPUSH, boolValue ? 1 : 0);
            jasminInstruction("bipush " + (boolValue ? "1" : "0"));
        } else if (value instanceof Character) {
            char charValue = (Character) value;
            methodGenerator.visitIntInsn(BIPUSH, (int) charValue);
            jasminInstruction("bipush " + (int) charValue + " ; '" + charValue + "'");
        } else {
            throw new UnsupportedOperationException("Unsupported literal type: " + value.getClass());
        }
        
        return null;
    }
    
    @Override
    public Void visitIdentifierExpression(IdentifierExpression expr) {
        String varName = expr.getName();
        Integer slot = localVariables.get(varName);
        
        if (slot != null) {
            // Local variable - load from local slot
            com.juno.types.Type varType = expr.getType();
            loadVariable(varType, slot);
        } else if (globalVariables.containsKey(varName)) {
            // Global variable - load from static field
            com.juno.types.Type varType = globalVariables.get(varName);
            String fieldDescriptor = getJVMTypeDescriptor(varType);
            methodGenerator.visitFieldInsn(GETSTATIC, currentClassName, varName, fieldDescriptor);
        } else {
            throw new RuntimeException("Undefined variable: " + varName);
        }
        
        return null;
    }
    
    @Override
    public Void visitAssignmentExpression(AssignmentExpression expr) {
        if (!(expr.getTarget() instanceof IdentifierExpression)) {
            throw new UnsupportedOperationException("Only simple variable assignment supported");
        }
        
        IdentifierExpression target = (IdentifierExpression) expr.getTarget();
        String varName = target.getName();
        Integer slot = localVariables.get(varName);
        
        if (slot == null) {
            throw new RuntimeException("Undefined variable: " + varName);
        }
        
        // Generate value
        expr.getValue().accept(this);
        
        // Duplicate value on stack (assignment returns the assigned value)
        methodGenerator.visitInsn(DUP);
        
        // Store in variable
        com.juno.types.Type varType = expr.getType();
        storeVariable(varType, slot);
        
        return null;
    }
    
    @Override
    public Void visitCallExpression(CallExpression expr) {
        Expression function = expr.getFunction();
        String functionName;
        
        // Extract function name (for now, only support simple identifier functions)
        if (function instanceof IdentifierExpression) {
            functionName = ((IdentifierExpression) function).getName();
        } else {
            throw new UnsupportedOperationException("Only simple function calls supported: " + function.getClass());
        }
        
        // Generate arguments
        for (Expression arg : expr.getArguments()) {
            arg.accept(this);
        }
        
        // For now, assume all functions are static methods in the same class
        // TODO: Handle function signatures properly
        String methodDescriptor = buildFunctionCallDescriptor(expr);
        methodGenerator.visitMethodInsn(INVOKESTATIC, currentClassName, functionName, methodDescriptor, false);
        jasminInstruction("invokestatic " + currentClassName + "/" + functionName + methodDescriptor);
        
        return null;
    }
    
    @Override
    public Void visitQualifiedIdentifier(QualifiedIdentifier expr) {
        // TODO: Implement module-qualified identifiers
        throw new UnsupportedOperationException("Qualified identifiers not yet supported in code generation");
    }
    
    @Override
    public Void visitCastExpression(CastExpression expr) {
        com.juno.types.Type sourceType = expr.getExpression().getType();
        com.juno.types.Type targetType = expr.getTargetType();
        
        // Generate the expression to be cast
        expr.getExpression().accept(this);
        
        // Emit type conversion instructions
        generateTypeConversion(sourceType, targetType);
        
        return null;
    }
    
    // ===== UTILITY METHODS =====
    
    private String buildMethodDescriptor(FunctionDeclaration funcDecl) {
        StringBuilder descriptor = new StringBuilder("(");
        
        // Parameter types
        for (FunctionDeclaration.Parameter param : funcDecl.getParameters()) {
            descriptor.append(getJVMTypeDescriptor(param.type));
        }
        
        descriptor.append(")");
        
        // Return type
        descriptor.append(getJVMTypeDescriptor(funcDecl.getReturnType()));
        
        return descriptor.toString();
    }
    
    private String buildFunctionCallDescriptor(CallExpression callExpr) {
        StringBuilder descriptor = new StringBuilder("(");
        
        // Parameter types (inferred from argument types)
        // TODO: This is a hack - we should look up the actual method signature
        for (Expression arg : callExpr.getArguments()) {
            com.juno.types.Type argType = arg.getType();
            
            // Most expressions produce int values on the JVM stack regardless of AST type
            // Only long-returning function calls actually produce long values
            if (isCallExpressionReturningLong(arg)) {
                descriptor.append("J"); // Function call returning long
            } else if (argType != null && isLongType(argType) && isLongLiteralExpression(arg)) {
                descriptor.append("J"); // Large long literal that actually needs long
            } else {
                descriptor.append("I"); // Everything else produces int on JVM stack
            }
        }
        
        descriptor.append(")");
        
        // Return type (from the call expression's type)
        com.juno.types.Type returnType = callExpr.getType();
        descriptor.append(getJVMTypeDescriptor(returnType));
        
        return descriptor.toString();
    }
    
    private String getJVMTypeDescriptor(com.juno.types.Type type) {
        if (type instanceof PrimitiveType) {
            switch (type.getName()) {
                case "void": return "V";
                case "bool": return "Z";
                case "byte": case "ubyte": 
                case "short": case "ushort": 
                case "int": case "uint": return "I";  // Use int for all small integer types
                case "long": case "ulong": return "J";
                case "float": return "F";
                case "double": return "D";
                case "char": return "C";
                case "string": return "Ljava/lang/String;";
                default: throw new UnsupportedOperationException("Unsupported primitive type: " + type.getName());
            }
        } else {
            // For now, treat complex types as Object
            return "Ljava/lang/Object;";
        }
    }
    
    private int getTypeSize(com.juno.types.Type type) {
        if (type instanceof PrimitiveType) {
            switch (type.getName()) {
                case "long": case "ulong": case "double":
                    return 2;  // 64-bit types take 2 slots
                default:
                    return 1;  // All other types take 1 slot
            }
        }
        return 1;
    }
    
    private void loadVariable(com.juno.types.Type type, int slot) {
        if (type == null) {
            methodGenerator.visitVarInsn(ILOAD, slot);  // Default to int
            jasminInstruction("iload " + slot);
            return;
        }
        
        if (type instanceof PrimitiveType) {
            switch (type.getName()) {
                case "bool": case "byte": case "ubyte": 
                case "short": case "ushort": case "int": case "uint": case "char":
                    methodGenerator.visitVarInsn(ILOAD, slot);
                    jasminInstruction("iload " + slot);
                    break;
                case "long": case "ulong":
                    methodGenerator.visitVarInsn(LLOAD, slot);
                    jasminInstruction("lload " + slot);
                    break;
                case "float":
                    methodGenerator.visitVarInsn(FLOAD, slot);
                    jasminInstruction("fload " + slot);
                    break;
                case "double":
                    methodGenerator.visitVarInsn(DLOAD, slot);
                    jasminInstruction("dload " + slot);
                    break;
                case "string":
                    methodGenerator.visitVarInsn(ALOAD, slot);
                    jasminInstruction("aload " + slot);
                    break;
                default:
                    methodGenerator.visitVarInsn(ILOAD, slot);
                    jasminInstruction("iload " + slot);
            }
        } else {
            methodGenerator.visitVarInsn(ALOAD, slot);  // Object reference
            jasminInstruction("aload " + slot);
        }
    }
    
    private void storeVariable(com.juno.types.Type type, int slot) {
        if (type == null) {
            methodGenerator.visitVarInsn(ISTORE, slot);  // Default to int
            jasminInstruction("istore " + slot);
            return;
        }
        
        if (type instanceof PrimitiveType) {
            switch (type.getName()) {
                case "bool": case "byte": case "ubyte":
                case "short": case "ushort": case "int": case "uint": case "char":
                    methodGenerator.visitVarInsn(ISTORE, slot);
                    jasminInstruction("istore " + slot);
                    break;
                case "long": case "ulong":
                    methodGenerator.visitVarInsn(LSTORE, slot);
                    jasminInstruction("lstore " + slot);
                    break;
                case "float":
                    methodGenerator.visitVarInsn(FSTORE, slot);
                    jasminInstruction("fstore " + slot);
                    break;
                case "double":
                    methodGenerator.visitVarInsn(DSTORE, slot);
                    jasminInstruction("dstore " + slot);
                    break;
                case "string":
                    methodGenerator.visitVarInsn(ASTORE, slot);
                    jasminInstruction("astore " + slot);
                    break;
                default:
                    methodGenerator.visitVarInsn(ISTORE, slot);
                    jasminInstruction("istore " + slot);
            }
        } else {
            methodGenerator.visitVarInsn(ASTORE, slot);  // Object reference
            jasminInstruction("astore " + slot);
        }
    }
    
    private void generateDefaultValue(com.juno.types.Type type) {
        if (type instanceof PrimitiveType) {
            switch (type.getName()) {
                case "bool": case "byte": case "ubyte":
                case "short": case "ushort": case "int": case "uint": case "char":
                    methodGenerator.visitInsn(ICONST_0);
                    break;
                case "long": case "ulong":
                    methodGenerator.visitInsn(LCONST_0);
                    break;
                case "float":
                    methodGenerator.visitInsn(FCONST_0);
                    break;
                case "double":
                    methodGenerator.visitInsn(DCONST_0);
                    break;
                case "string":
                    methodGenerator.visitInsn(ACONST_NULL);
                    break;
                default:
                    methodGenerator.visitInsn(ICONST_0);
            }
        } else {
            methodGenerator.visitInsn(ACONST_NULL);
        }
    }
    
    private void generateReturn(com.juno.types.Type returnType) {
        if (returnType instanceof PrimitiveType) {
            switch (returnType.getName()) {
                case "void":
                    methodGenerator.visitInsn(RETURN);
                    jasminInstruction("return");
                    break;
                case "bool": case "byte": case "ubyte":
                case "short": case "ushort": case "int": case "uint": case "char":
                    methodGenerator.visitInsn(IRETURN);
                    jasminInstruction("ireturn");
                    break;
                case "long": case "ulong":
                    methodGenerator.visitInsn(LRETURN);
                    jasminInstruction("lreturn");
                    break;
                case "float":
                    methodGenerator.visitInsn(FRETURN);
                    jasminInstruction("freturn");
                    break;
                case "double":
                    methodGenerator.visitInsn(DRETURN);
                    jasminInstruction("dreturn");
                    break;
                case "string":
                    methodGenerator.visitInsn(ARETURN);
                    jasminInstruction("areturn");
                    break;
                default:
                    methodGenerator.visitInsn(IRETURN);
                    jasminInstruction("ireturn");
            }
        } else {
            methodGenerator.visitInsn(ARETURN);
            jasminInstruction("areturn");
        }
    }
    
    private void generateComparison(int compareOpcode) {
        Label trueLabel = methodGenerator.newLabel();
        Label endLabel = methodGenerator.newLabel();
        int trueLabelId = ++labelCounter;
        int endLabelId = ++labelCounter;
        
        // Compare and jump to true label if condition holds
        methodGenerator.visitJumpInsn(compareOpcode, trueLabel);
        String jumpInstr = getJumpInstructionName(compareOpcode);
        jasminInstruction(jumpInstr + " true_" + trueLabelId);
        
        // False case: push 0
        methodGenerator.visitInsn(ICONST_0);
        jasminInstruction("iconst_0");
        methodGenerator.visitJumpInsn(GOTO, endLabel);
        jasminInstruction("goto end_" + endLabelId);
        
        // True case: push 1
        methodGenerator.visitLabel(trueLabel);
        jasminLabel("true_" + trueLabelId);
        methodGenerator.visitInsn(ICONST_1);
        jasminInstruction("iconst_1");
        
        methodGenerator.visitLabel(endLabel);
        jasminLabel("end_" + endLabelId);
    }
    
    private void generateLogicalNot() {
        Label trueLabel = methodGenerator.newLabel();
        Label endLabel = methodGenerator.newLabel();
        
        // If value is 0 (false), jump to true label
        methodGenerator.visitJumpInsn(IFEQ, trueLabel);
        
        // Value was non-zero (true), so result is false (0)
        methodGenerator.visitInsn(ICONST_0);
        methodGenerator.visitJumpInsn(GOTO, endLabel);
        
        // Value was zero (false), so result is true (1)
        methodGenerator.visitLabel(trueLabel);
        methodGenerator.visitInsn(ICONST_1);
        
        methodGenerator.visitLabel(endLabel);
    }
    
    private void generateLogicalAnd() {
        Label falseLabel = methodGenerator.newLabel();
        Label endLabel = methodGenerator.newLabel();
        
        // Left operand is already on stack
        // Duplicate it for the test
        methodGenerator.visitInsn(DUP);
        methodGenerator.visitJumpInsn(IFEQ, falseLabel);  // If left is false, short-circuit
        
        // Left was true, pop it and use right operand result
        methodGenerator.visitInsn(POP);
        // Right operand is already on stack
        methodGenerator.visitJumpInsn(GOTO, endLabel);
        
        // Left was false, pop right operand and push false
        methodGenerator.visitLabel(falseLabel);
        methodGenerator.visitInsn(POP);  // Pop right operand
        methodGenerator.visitInsn(ICONST_0);
        
        methodGenerator.visitLabel(endLabel);
    }
    
    private void generateLogicalOr() {
        Label trueLabel = methodGenerator.newLabel();
        Label endLabel = methodGenerator.newLabel();
        
        // Left operand is already on stack
        // Duplicate it for the test
        methodGenerator.visitInsn(DUP);
        methodGenerator.visitJumpInsn(IFNE, trueLabel);  // If left is true, short-circuit
        
        // Left was false, pop it and use right operand result
        methodGenerator.visitInsn(POP);
        // Right operand is already on stack
        methodGenerator.visitJumpInsn(GOTO, endLabel);
        
        // Left was true, pop right operand and push true
        methodGenerator.visitLabel(trueLabel);
        methodGenerator.visitInsn(POP);  // Pop right operand
        methodGenerator.visitInsn(ICONST_1);
        
        methodGenerator.visitLabel(endLabel);
    }
    
    private String getJumpInstructionName(int opcode) {
        switch (opcode) {
            case IF_ICMPEQ: return "if_icmpeq";
            case IF_ICMPNE: return "if_icmpne";
            case IF_ICMPLT: return "if_icmplt";
            case IF_ICMPLE: return "if_icmple";
            case IF_ICMPGT: return "if_icmpgt";
            case IF_ICMPGE: return "if_icmpge";
            default: return "if_icmp_unknown";
        }
    }
    
    // ===== TYPE CONVERSION METHODS =====
    
    private boolean needsTypeConversion(com.juno.types.Type fromType, com.juno.types.Type toType) {
        if (fromType == null || toType == null) {
            return false;
        }
        
        // If types are the same, no conversion needed
        if (fromType.getName().equals(toType.getName())) {
            return false;
        }
        
        // Check if conversion from int to long is needed (common case for literals)
        if (isIntegerType(fromType) && isLongType(toType)) {
            return true;
        }
        
        // Add more conversion rules as needed
        return false;
    }
    
    /**
     * Generate JVM bytecode instructions to convert from one type to another.
     * Assumes the source value is already on the stack.
     */
    private void generateTypeConversion(com.juno.types.Type fromType, com.juno.types.Type toType) {
        if (fromType == null || toType == null) {
            return; // No conversion possible
        }
        
        // If types are the same, no conversion needed
        String fromTypeName = fromType.getName();
        String toTypeName = toType.getName();
        
        if (fromTypeName.equals(toTypeName)) {
            return; // No conversion needed
        }
        
        // Handle primitive type conversions
        if (fromType instanceof PrimitiveType && toType instanceof PrimitiveType) {
            generatePrimitiveTypeConversion(fromTypeName, toTypeName);
        } else {
            // For non-primitive types, assume no conversion is needed for now
            // TODO: Handle object type conversions, boxing/unboxing
        }
    }
    
    /**
     * Generate conversion instructions for primitive types.
     */
    private void generatePrimitiveTypeConversion(String fromTypeName, String toTypeName) {
        // Handle integer to integer conversions
        if (isIntegerTypeName(fromTypeName) && isIntegerTypeName(toTypeName)) {
            generateIntegerToIntegerConversion(fromTypeName, toTypeName);
        }
        // Handle integer to floating point conversions
        else if (isIntegerTypeName(fromTypeName) && isFloatingPointTypeName(toTypeName)) {
            generateIntegerToFloatConversion(fromTypeName, toTypeName);
        }
        // Handle floating point to integer conversions
        else if (isFloatingPointTypeName(fromTypeName) && isIntegerTypeName(toTypeName)) {
            generateFloatToIntegerConversion(fromTypeName, toTypeName);
        }
        // Handle floating point to floating point conversions
        else if (isFloatingPointTypeName(fromTypeName) && isFloatingPointTypeName(toTypeName)) {
            generateFloatToFloatConversion(fromTypeName, toTypeName);
        }
        // Handle character conversions
        else if ("char".equals(fromTypeName) && isIntegerTypeName(toTypeName)) {
            // char -> integer (char is already stored as int in JVM)
            if ("long".equals(toTypeName) || "ulong".equals(toTypeName)) {
                methodGenerator.visitInsn(I2L);
                jasminInstruction("i2l ; char to long");
            }
            // For other integer types, no conversion needed (char is already int on JVM)
        }
        else if (isIntegerTypeName(fromTypeName) && "char".equals(toTypeName)) {
            // integer -> char (truncate to char range)
            if ("long".equals(fromTypeName) || "ulong".equals(fromTypeName)) {
                methodGenerator.visitInsn(L2I);
                jasminInstruction("l2i ; long to char via int");
            }
            // For other integer types, no conversion needed (already int on JVM)
        }
        // Handle bool conversions
        else if ("bool".equals(fromTypeName) && isIntegerTypeName(toTypeName)) {
            if ("long".equals(toTypeName) || "ulong".equals(toTypeName)) {
                methodGenerator.visitInsn(I2L);
                jasminInstruction("i2l ; bool to long");
            }
            // For other integer types, no conversion needed (bool is already int on JVM)
        }
        else if (isIntegerTypeName(fromTypeName) && "bool".equals(toTypeName)) {
            if ("long".equals(fromTypeName) || "ulong".equals(fromTypeName)) {
                methodGenerator.visitInsn(L2I);
                jasminInstruction("l2i ; long to bool via int");
            }
            // TODO: Consider adding bounds checking for bool conversion (ensure 0 or 1)
        }
    }
    
    private void generateIntegerToIntegerConversion(String fromTypeName, String toTypeName) {
        // From smaller integer types to long
        if (("int".equals(fromTypeName) || "uint".equals(fromTypeName) ||
             "byte".equals(fromTypeName) || "ubyte".equals(fromTypeName) ||
             "short".equals(fromTypeName) || "ushort".equals(fromTypeName)) &&
            ("long".equals(toTypeName) || "ulong".equals(toTypeName))) {
            methodGenerator.visitInsn(I2L);
            jasminInstruction("i2l ; " + fromTypeName + " to " + toTypeName);
        }
        // From long to smaller integer types
        else if (("long".equals(fromTypeName) || "ulong".equals(fromTypeName)) &&
                 ("int".equals(toTypeName) || "uint".equals(toTypeName) ||
                  "byte".equals(toTypeName) || "ubyte".equals(toTypeName) ||
                  "short".equals(toTypeName) || "ushort".equals(toTypeName))) {
            methodGenerator.visitInsn(L2I);
            jasminInstruction("l2i ; " + fromTypeName + " to " + toTypeName);
            
            // Additional narrowing if needed
            if ("byte".equals(toTypeName) || "ubyte".equals(toTypeName)) {
                methodGenerator.visitInsn(I2B);
                jasminInstruction("i2b ; narrow to byte");
            } else if ("short".equals(toTypeName) || "ushort".equals(toTypeName)) {
                methodGenerator.visitInsn(I2S);
                jasminInstruction("i2s ; narrow to short");
            }
        }
        // From int to smaller integer types (byte, short)
        else if (("int".equals(fromTypeName) || "uint".equals(fromTypeName)) &&
                 ("byte".equals(toTypeName) || "ubyte".equals(toTypeName))) {
            methodGenerator.visitInsn(I2B);
            jasminInstruction("i2b ; " + fromTypeName + " to " + toTypeName);
        }
        else if (("int".equals(fromTypeName) || "uint".equals(fromTypeName)) &&
                 ("short".equals(toTypeName) || "ushort".equals(toTypeName))) {
            methodGenerator.visitInsn(I2S);
            jasminInstruction("i2s ; " + fromTypeName + " to " + toTypeName);
        }
        // No conversion needed for same-sized integer types (int/uint, long/ulong, etc.)
    }
    
    private void generateIntegerToFloatConversion(String fromTypeName, String toTypeName) {
        if ("long".equals(fromTypeName) || "ulong".equals(fromTypeName)) {
            if ("float".equals(toTypeName)) {
                methodGenerator.visitInsn(L2F);
                jasminInstruction("l2f ; " + fromTypeName + " to float");
            } else if ("double".equals(toTypeName)) {
                methodGenerator.visitInsn(L2D);
                jasminInstruction("l2d ; " + fromTypeName + " to double");
            }
        } else {
            // From int-sized types to float
            if ("float".equals(toTypeName)) {
                methodGenerator.visitInsn(I2F);
                jasminInstruction("i2f ; " + fromTypeName + " to float");
            } else if ("double".equals(toTypeName)) {
                methodGenerator.visitInsn(I2D);
                jasminInstruction("i2d ; " + fromTypeName + " to double");
            }
        }
    }
    
    private void generateFloatToIntegerConversion(String fromTypeName, String toTypeName) {
        // First convert to int or long
        if ("float".equals(fromTypeName)) {
            if ("long".equals(toTypeName) || "ulong".equals(toTypeName)) {
                methodGenerator.visitInsn(F2L);
                jasminInstruction("f2l ; float to " + toTypeName);
            } else {
                methodGenerator.visitInsn(F2I);
                jasminInstruction("f2i ; float to " + toTypeName);
                
                // Additional narrowing if needed
                if ("byte".equals(toTypeName) || "ubyte".equals(toTypeName)) {
                    methodGenerator.visitInsn(I2B);
                    jasminInstruction("i2b ; narrow to byte");
                } else if ("short".equals(toTypeName) || "ushort".equals(toTypeName)) {
                    methodGenerator.visitInsn(I2S);
                    jasminInstruction("i2s ; narrow to short");
                }
            }
        } else if ("double".equals(fromTypeName)) {
            if ("long".equals(toTypeName) || "ulong".equals(toTypeName)) {
                methodGenerator.visitInsn(D2L);
                jasminInstruction("d2l ; double to " + toTypeName);
            } else {
                methodGenerator.visitInsn(D2I);
                jasminInstruction("d2i ; double to " + toTypeName);
                
                // Additional narrowing if needed
                if ("byte".equals(toTypeName) || "ubyte".equals(toTypeName)) {
                    methodGenerator.visitInsn(I2B);
                    jasminInstruction("i2b ; narrow to byte");
                } else if ("short".equals(toTypeName) || "ushort".equals(toTypeName)) {
                    methodGenerator.visitInsn(I2S);
                    jasminInstruction("i2s ; narrow to short");
                }
            }
        }
    }
    
    private void generateFloatToFloatConversion(String fromTypeName, String toTypeName) {
        if ("float".equals(fromTypeName) && "double".equals(toTypeName)) {
            methodGenerator.visitInsn(F2D);
            jasminInstruction("f2d ; float to double");
        } else if ("double".equals(fromTypeName) && "float".equals(toTypeName)) {
            methodGenerator.visitInsn(D2F);
            jasminInstruction("d2f ; double to float");
        }
    }
    
    private boolean isIntegerTypeName(String typeName) {
        return "int".equals(typeName) || "uint".equals(typeName) ||
               "long".equals(typeName) || "ulong".equals(typeName) ||
               "byte".equals(typeName) || "ubyte".equals(typeName) ||
               "short".equals(typeName) || "ushort".equals(typeName);
    }
    
    private boolean isFloatingPointTypeName(String typeName) {
        return "float".equals(typeName) || "double".equals(typeName);
    }
    
    private boolean isIntegerType(com.juno.types.Type type) {
        if (!(type instanceof PrimitiveType)) {
            return false;
        }
        String typeName = type.getName();
        return typeName.equals("int") || typeName.equals("uint") || 
               typeName.equals("byte") || typeName.equals("ubyte") ||
               typeName.equals("short") || typeName.equals("ushort");
    }
    
    private boolean isLongType(com.juno.types.Type type) {
        if (!(type instanceof PrimitiveType)) {
            return false;
        }
        String typeName = type.getName();
        return typeName.equals("long") || typeName.equals("ulong");
    }
    
    private boolean isCallExpressionReturningLong(Expression expr) {
        // Check if this expression is a function call that returns a long type
        if (expr instanceof CallExpression) {
            CallExpression callExpr = (CallExpression) expr;
            com.juno.types.Type returnType = callExpr.getType();
            return returnType != null && isLongType(returnType);
        }
        return false;
    }
    
    private boolean isLongLiteralExpression(Expression expr) {
        // Check if this is a literal that actually needs to be represented as long
        if (expr instanceof LiteralExpression) {
            LiteralExpression litExpr = (LiteralExpression) expr;
            Object value = litExpr.getValue();
            if (value instanceof Long) {
                long longValue = (Long) value;
                // Only use long descriptor for values that don't fit in int
                return longValue < Integer.MIN_VALUE || longValue > Integer.MAX_VALUE;
            }
        }
        return false;
    }
    
    private boolean isLongArithmetic(Expression left, Expression right) {
        // Use long arithmetic if either operand produces a long value on the stack
        return producesLongValue(left) || producesLongValue(right);
    }
    
    private boolean producesLongValue(Expression expr) {
        // Check if this expression produces a long value on the JVM stack
        return isCallExpressionReturningLong(expr) || isLongLiteralExpression(expr);
    }
    
    private boolean isLongArithmeticExpression(Expression expr) {
        // Check if this is a binary expression that uses long arithmetic
        if (expr instanceof BinaryExpression) {
            BinaryExpression binExpr = (BinaryExpression) expr;
            String operator = binExpr.getOperator();
            // Check if it's an arithmetic operator that can produce long results
            if ("+".equals(operator) || "-".equals(operator) || 
                "*".equals(operator) || "/".equals(operator) || "%".equals(operator)) {
                return isLongArithmetic(binExpr.getLeft(), binExpr.getRight());
            }
        }
        return false;
    }
    
    // ===== JASMIN ASSEMBLY GENERATION =====
    
    private void generateJasminHeader(String className) {
        jasminOutput.append(".class public ").append(className).append("\n");
        jasminOutput.append(".super java/lang/Object\n\n");
        
        // Generate default constructor
        jasminOutput.append(".method public <init>()V\n");
        jasminOutput.append("    .limit stack 1\n");
        jasminOutput.append("    .limit locals 1\n");
        jasminOutput.append("    aload_0\n");
        jasminOutput.append("    invokespecial java/lang/Object/<init>()V\n");
        jasminOutput.append("    return\n");
        jasminOutput.append(".end method\n\n");
    }
    
    private void jasminComment(String comment) {
        jasminOutput.append("; ").append(comment).append("\n");
    }
    
    private void jasminInstruction(String instruction) {
        jasminOutput.append("    ").append(instruction).append("\n");
    }
    
    private void jasminLabel(String label) {
        jasminOutput.append(label).append(":\n");
    }
    
    private void jasminDirective(String directive) {
        jasminOutput.append(directive).append("\n");
    }
    
    private void jasminMethod(String signature, String access) {
        jasminOutput.append(".method ").append(access).append(" ").append(signature).append("\n");
    }
    
    private void jasminEndMethod() {
        jasminOutput.append(".end method\n\n");
    }
    
    private void jasminField(String name, String descriptor, String access) {
        jasminOutput.append(".field ").append(access).append(" ")
                   .append(name).append(" ").append(descriptor).append("\n");
    }
    
    private void generateStaticInitializer() {
        if (globalInitializers.isEmpty()) {
            return; // No initialization needed
        }
        
        // Create static initializer method <clinit>
        MethodVisitor clinit = classWriter.visitMethod(ACC_STATIC, "<clinit>", "()V", null, null);
        methodGenerator = new GeneratorAdapter(ACC_STATIC, new Method("<clinit>", "()V"), clinit);
        
        // Generate Jasmin static initializer
        jasminComment("Static initializer for global variables");
        jasminMethod("<clinit>()V", "static");
        jasminDirective("    .limit stack 10");
        jasminDirective("    .limit locals 1");
        
        methodGenerator.visitCode();
        
        // Initialize each global variable with its initializer
        for (String varName : globalInitializers.keySet()) {
            Expression initializer = globalInitializers.get(varName);
            com.juno.types.Type varType = globalVariables.get(varName);
            
            jasminComment("Initialize " + varName);
            
            // Generate initialization value
            initializer.accept(this);
            
            // Add type conversion if needed
            if (varType instanceof PrimitiveType && varType.getName().equals("float") &&
                initializer instanceof LiteralExpression) {
                Object value = ((LiteralExpression) initializer).getValue();
                if (value instanceof Double) {
                    // Convert double to float on the stack
                    methodGenerator.visitInsn(D2F);
                    jasminInstruction("d2f");
                }
            }
            
            // Store in static field
            String fieldDescriptor = getJVMTypeDescriptor(varType);
            methodGenerator.visitFieldInsn(PUTSTATIC, currentClassName, varName, fieldDescriptor);
        }
        
        // Return from static initializer
        methodGenerator.visitInsn(RETURN);
        methodGenerator.visitMaxs(0, 0);
        methodGenerator.visitEnd();
        
        // End Jasmin static initializer
        jasminInstruction("return");
        jasminEndMethod();
        
        // Clear method generator
        methodGenerator = null;
    }
    
    private void generateJvmMainMethod() {
        if (!hasJunoMainMethod) {
            return; // No Juno main method to wrap
        }
        
        // Create JVM-compatible main method: public static void main(String[] args)
        MethodVisitor mainMethod = classWriter.visitMethod(
            ACC_PUBLIC | ACC_STATIC, 
            "main", 
            "([Ljava/lang/String;)V", 
            null, 
            null
        );
        
        methodGenerator = new GeneratorAdapter(ACC_PUBLIC | ACC_STATIC, 
            new Method("main", "([Ljava/lang/String;)V"), mainMethod);
        
        // Generate Jasmin JVM main method
        jasminComment("JVM-compatible main method wrapper");
        jasminMethod("main([Ljava/lang/String;)V", "public static");
        jasminDirective("    .limit stack 10");
        jasminDirective("    .limit locals 1");
        
        methodGenerator.visitCode();
        
        // Determine if Juno main returns int or long
        boolean isLongMain = junoMainReturnType != null && isLongType(junoMainReturnType);
        String callDescriptor = isLongMain ? "()J" : "()I";
        String printDescriptor = isLongMain ? "(J)V" : "(I)V";
        
        // Call our Juno main() method and get the result
        methodGenerator.visitMethodInsn(INVOKESTATIC, currentClassName, "main", callDescriptor, false);
        jasminInstruction("invokestatic " + currentClassName + "/main" + callDescriptor);
        
        // Print the result to stdout (standard JVM behavior)
        methodGenerator.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
        jasminInstruction("getstatic java/lang/System/out Ljava/io/PrintStream;");
        
        if (isLongMain) {
            // For long values: stack is [long_low, long_high, PrintStream]
            // We need: [PrintStream, long_low, long_high]
            // Use DUP_X2 then POP to reorder
            methodGenerator.visitInsn(DUP_X2);  // [PrintStream, long_low, long_high, PrintStream]
            methodGenerator.visitInsn(POP);     // [PrintStream, long_low, long_high]
            jasminInstruction("dup_x2");
            jasminInstruction("pop");
        } else {
            methodGenerator.visitInsn(SWAP);  // Put int result before PrintStream
            jasminInstruction("swap");
        }
        
        methodGenerator.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", printDescriptor, false);
        jasminInstruction("invokevirtual java/io/PrintStream/println" + printDescriptor);
        
        // Return void (standard JVM main behavior)
        methodGenerator.visitInsn(RETURN);
        jasminInstruction("return");
        
        methodGenerator.visitMaxs(0, 0);
        methodGenerator.visitEnd();
        
        // End Jasmin JVM main method
        jasminEndMethod();
        
        // Clear method generator
        methodGenerator = null;
    }
}
